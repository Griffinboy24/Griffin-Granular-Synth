#pragma once

#include <JuceHeader.h>
#include <array>
#include <vector>
#include <complex>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <atomic>

//==============================================================================
// FFTProcessor
//
// This header-only class implements an FFT analysis/resynthesis system using
// overlap-add processing. The FFT size is fixed (power of 2) so that the number
// of frequency bins is constant, and a lowpass cutoff frequency (in Hz) is applied
// by zeroing out bins above the cutoff. The cutoff is converted to a bin index
// using the current sample rate.
//
// Thread safety is ensured via atomic counters. All static data (such as the window
// coefficients) are precomputed in double precision and then converted to float.
// No dynamic memory allocation occurs on the realtime audio path.
//==============================================================================
class FFTProcessor
{
public:
    // FFT configuration constants.
    static constexpr int fftOrder = 11;           // log2(fftSize); 2048 samples per frame.
    static constexpr int fftSize = 1 << fftOrder;   // 2048 samples per FFT frame.
    static constexpr int numBins = fftSize / 2 + 1; // Number of frequency bins.
    static constexpr int overlap = 4;             // 75% overlap (4 segments per frame).
    static constexpr int hopSize = fftSize / overlap; // For example, 2048/4 = 512 samples per hop.

    // Gain correction for the Hann window with 75% overlap.
    static constexpr float windowCorrection = 2.0f / 3.0f;

    // Public interface to update parameters.
    inline void setSampleRate(float sr)
    {
        currentSampleRate = sr;
    }

    inline void setLowpassCutoff(float freqHz)
    {
        lowpassCutoffFrequency = freqHz;
    }

    // Constructor: sets default sample rate, lowpass cutoff and precomputes window table.
    FFTProcessor() :
        fft(fftOrder),
        currentSampleRate(44100.0f),
        lowpassCutoffFrequency(5000.0f),
        pos(0),
        count(0)
    {
        // Precompute the Hann window using double precision.
        windowTable.resize(fftSize);
        for (int i = 0; i < fftSize; ++i)
        {
            // Use the Hann formula over [0, fftSize-1] (periodic window)
            double w = 0.5 * (1.0 - std::cos((2.0 * M_PI * i) / static_cast<double>(fftSize)));
            windowTable[i] = static_cast<float>(w);
        }
    }

    // reset() -- Clears internal counters and zeroes the input and output buffers.
    inline void reset()
    {
        count.store(0, std::memory_order_relaxed);
        pos.store(0, std::memory_order_relaxed);
        inputFifo.fill(0.0f);
        outputFifo.fill(0.0f);
    }

    // processSample() -- Processes one sample and returns the corresponding output.
    // If bypassed is true, the FFT processing is skipped.
    inline float processSample(float sample, bool bypassed)
    {
        // Store incoming sample into circular input buffer.
        int p = pos.load(std::memory_order_relaxed);
        inputFifo[p] = sample;

        // Retrieve corresponding output sample.
        float outputSample = outputFifo[p];

        // Clear output slot for future overlap-add.
        outputFifo[p] = 0.0f;

        // Update circular index (bitmasking works because fftSize is power of 2).
        p = (p + 1) & (fftSize - 1);
        pos.store(p, std::memory_order_relaxed);

        // Accumulate samples; when hopSize is reached, process an FFT frame.
        int c = count.load(std::memory_order_relaxed) + 1;
        if (c >= hopSize)
        {
            c = 0;
            processFrame(bypassed);
        }
        count.store(c, std::memory_order_relaxed);
        return outputSample;
    }

    // flushRemaining() -- Processes an extra fftSize samples (zeros) to flush residuals.
    // Returns the extra output samples.
    inline std::vector<float> flushRemaining(bool bypassed)
    {
        std::vector<float> flushed;
        flushed.reserve(fftSize);
        for (int i = 0; i < fftSize; ++i)
        {
            float out = processSample(0.0f, bypassed);
            flushed.push_back(out);
        }
        return flushed;
    }

private:
    // JUCE FFT object.
    juce::dsp::FFT fft;

    // Precomputed window table (Hann window computed in double precision then stored as float).
    std::vector<float> windowTable;

    // Internal counters (atomic for thread safety).
    std::atomic<int> count; // Number of samples accumulated for current hop.
    std::atomic<int> pos;   // Current index in the circular buffers.

    // Circular input and output buffers.
    std::array<float, fftSize> inputFifo{};
    std::array<float, fftSize> outputFifo{};

    // Working buffer for FFT processing (interleaved complex numbers).
    std::array<float, fftSize * 2> fftData{};

    // Current sample rate and lowpass cutoff frequency (both in Hz).
    float currentSampleRate;
    float lowpassCutoffFrequency;

    // frequencyToBin() -- Converts a frequency (Hz) to a bin index.
    inline int frequencyToBin(float frequency) const
    {
        int bin = static_cast<int>((frequency * fftSize) / currentSampleRate + 0.5f);
        return std::min(bin, numBins - 1);
    }

    // multiplyWindow() -- Applies the precomputed window to the buffer.
    inline void multiplyWindow(float* data, int numSamples)
    {
        // Use JUCE's vector math for fast multiplication.
        juce::FloatVectorOperations::multiply(data, windowTable.data(), numSamples);
    }

    // processFrame() -- Processes one FFT frame (when hopSize samples have been accumulated).
    inline void processFrame(bool bypassed)
    {
        // Copy fftSize samples from the circular input buffer to the working FFT buffer.
        const float* inputPtr = inputFifo.data();
        float* fftPtr = fftData.data();
        int p = pos.load(std::memory_order_relaxed);
        int samplesAfterPos = fftSize - p;
        std::memcpy(fftPtr, inputPtr + p, samplesAfterPos * sizeof(float));
        if (p > 0)
            std::memcpy(fftPtr + samplesAfterPos, inputPtr, p * sizeof(float));

        // Apply window to fftData.
        multiplyWindow(fftPtr, fftSize);

        if (!bypassed)
        {
            // Forward FFT (real-only). 'true' indicates output is in natural order.
            fft.performRealOnlyForwardTransform(fftPtr, true);
            // Process spectrum (apply lowpass filter).
            processSpectrum(fftPtr, numBins);
            // Inverse FFT to convert back to time domain.
            fft.performRealOnlyInverseTransform(fftPtr);
        }

        // Reapply window and apply gain correction.
        multiplyWindow(fftPtr, fftSize);
        // Use JUCE vector math to multiply entire buffer by windowCorrection.
        juce::FloatVectorOperations::multiply(fftPtr, fftPtr, windowCorrection, fftSize);

        // Overlap-add: add the processed frame into the output circular buffer.
        // First part: from index 0 to p-1.
        if (p > 0)
            juce::FloatVectorOperations::add(outputFifo.data(), fftPtr + fftSize - p, p);
        // Second part: from index p to fftSize-1.
        int remaining = fftSize - p;
        if (remaining > 0)
            juce::FloatVectorOperations::add(outputFifo.data() + p, fftPtr, remaining);
    }

    // processSpectrum() -- Applies a lowpass filter by zeroing out frequency bins above the cutoff.
    inline void processSpectrum(float* data, int numBins)
    {
        // reinterpret data as complex numbers.
        auto* cdata = reinterpret_cast<std::complex<float>*>(data);
        int cutoffBin = frequencyToBin(lowpassCutoffFrequency);
        for (int i = 0; i < numBins; ++i)
        {
            float magnitude = std::abs(cdata[i]);
            float phase = std::arg(cdata[i]);
            if (i > cutoffBin)
                magnitude = 0.0f;
            cdata[i] = std::polar(magnitude, phase);
        }
    }
};
