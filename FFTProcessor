#pragma once

#include <JuceHeader.h>
#include <array>
#include <vector>
#include <complex>
#include <cstring>
#include <cmath>
#include <algorithm>

//==============================================================================
// FFTProcessor
//
// This header-only class implements an FFT analysis/resynthesis system using
// overlap-add processing. The number of frequency bins is fixed based on a 
// constant FFT size, and a lowpass cutoff frequency in Hz can be specified 
// independent of the sample rate. The cutoff frequency is converted to a bin index
// using the current sample rate.
//==============================================================================
class FFTProcessor
{
public:
    // FFT configuration constants.
    static constexpr int fftOrder = 11;           // log2(fftSize), so fftSize = 2048
    static constexpr int fftSize = 1 << fftOrder;   // 2048 samples per FFT frame
    static constexpr int numBins = fftSize / 2 + 1; // Number of frequency bins for real FFT
    static constexpr int overlap = 4;             // 75% overlap (i.e. 4 segments per frame)
    static constexpr int hopSize = fftSize / overlap; // e.g. 2048/4 = 512 samples per hop

    // Gain correction for using the Hann window with 75% overlap.
    static constexpr float windowCorrection = 2.0f / 3.0f;

    // Set the current sample rate (in Hz).
    inline void setSampleRate(float sr)
    {
        currentSampleRate = sr;
    }

    // Set the lowpass cutoff frequency (in Hz).
    inline void setLowpassCutoff(float freqHz)
    {
        lowpassCutoffFrequency = freqHz;
    }

    // Constructor: initializes the FFT and window. Default sample rate is 44100 Hz,
    // and the default lowpass cutoff is 5000 Hz.
    FFTProcessor() :
        fft(fftOrder),
        window(fftSize + 1, juce::dsp::WindowingFunction<float>::hann, false),
        currentSampleRate(44100.0f),
        lowpassCutoffFrequency(5000.0f)
    {
    }

    // reset() -- Clears internal counters and zeroes the input/output buffers.
    inline void reset()
    {
        count = 0;
        pos = 0;
        inputFifo.fill(0.0f);
        outputFifo.fill(0.0f);
    }

    // processSample() -- Processes one sample and returns the corresponding output sample.
    // If "bypassed" is true, FFT processing is skipped.
    inline float processSample(float sample, bool bypassed)
    {
        // Store the incoming sample in the circular input buffer.
        inputFifo[pos] = sample;

        // Retrieve the corresponding output sample.
        float outputSample = outputFifo[pos];

        // Clear the output slot so new overlap-add data can be added.
        outputFifo[pos] = 0.0f;

        // Update the buffer index using bitmasking (efficient for power-of-2 sizes).
        pos = (pos + 1) & (fftSize - 1);

        // Count samples. When we've accumulated hopSize samples, process a frame.
        count++;
        if (count == hopSize)
        {
            count = 0;
            processFrame(bypassed);
        }
        return outputSample;
    }

    // flushRemaining() -- Process an extra fftSize samples (of zeros) to flush out
    // any residual data in the buffers. Returns the extra output samples.
    inline std::vector<float> flushRemaining(bool bypassed)
    {
        std::vector<float> flushed;
        for (int i = 0; i < fftSize; ++i)
        {
            float out = processSample(0.0f, bypassed);
            flushed.push_back(out);
        }
        return flushed;
    }

private:
    // JUCE objects for FFT and windowing.
    juce::dsp::FFT fft;
    juce::dsp::WindowingFunction<float> window;

    // Internal counters.
    int count = 0;  // Count of samples accumulated for the current hop.
    int pos = 0;    // Current index in the circular buffers.

    // Circular buffers for input and output samples.
    std::array<float, fftSize> inputFifo{};
    std::array<float, fftSize> outputFifo{};

    // Working buffer for FFT processing (stores interleaved complex numbers).
    std::array<float, fftSize * 2> fftData{};

    // Current sample rate (Hz) and lowpass cutoff frequency (Hz).
    float currentSampleRate;
    float lowpassCutoffFrequency;

    // frequencyToBin() -- Converts a frequency (Hz) to a bin index.
    inline int frequencyToBin(float frequency) const
    {
        // Each bin represents approximately (currentSampleRate / fftSize) Hz.
        int bin = static_cast<int>((frequency * fftSize) / currentSampleRate + 0.5f);
        return std::min(bin, numBins - 1);
    }

    // processFrame() -- Processes one FFT frame once hopSize samples have been accumulated.
    // This copies fftSize samples from the circular input buffer into the working buffer,
    // applies the window, performs FFT (if not bypassed), processes the spectrum,
    // performs the inverse FFT, reapplies the window, and overlaps-adds the result into
    // the output buffer.
    inline void processFrame(bool bypassed)
    {
        // Copy fftSize samples from the circular input buffer to fftData.
        // Because the buffer is circular, we need to copy in two segments.
        const float* inputPtr = inputFifo.data();
        float* fftPtr = fftData.data();
        int samplesAfterPos = fftSize - pos;
        std::memcpy(fftPtr, inputPtr + pos, samplesAfterPos * sizeof(float));
        if (pos > 0)
            std::memcpy(fftPtr + samplesAfterPos, inputPtr, pos * sizeof(float));

        // Apply the Hann window to reduce spectral leakage.
        window.multiplyWithWindowingTable(fftPtr, fftSize);

        if (!bypassed)
        {
            // Perform the forward FFT (real-only).
            fft.performRealOnlyForwardTransform(fftPtr, true);

            // Process the spectrum (apply a lowpass filter).
            processSpectrum(fftPtr, numBins);

            // Perform the inverse FFT to convert back to time domain.
            fft.performRealOnlyInverseTransform(fftPtr);
        }

        // Reapply the window to prepare for overlap-add synthesis.
        window.multiplyWithWindowingTable(fftPtr, fftSize);

        // Apply gain correction to account for overlapping windows.
        for (int i = 0; i < fftSize; ++i)
            fftPtr[i] *= windowCorrection;

        // Overlap-add: add the processed frame back into the output circular buffer.
        for (int i = 0; i < pos; ++i)
            outputFifo[i] += fftData[i + fftSize - pos];
        for (int i = 0; i < fftSize - pos; ++i)
            outputFifo[i + pos] += fftData[i];
    }

    // processSpectrum() -- Applies a spectral lowpass filter.
    // The lowpass cutoff (in Hz) is converted to a bin index; all bins above that index
    // have their magnitudes set to zero.
    inline void processSpectrum(float* data, int numBins)
    {
        // Treat the FFT data as an array of complex<float>.
        auto* cdata = reinterpret_cast<std::complex<float>*>(data);

        // Convert the lowpass cutoff frequency to a bin index.
        int cutoffBin = frequencyToBin(lowpassCutoffFrequency);

        for (int i = 0; i < numBins; ++i)
        {
            float magnitude = std::abs(cdata[i]);
            float phase = std::arg(cdata[i]);

            // Zero out frequencies above the cutoff.
            if (i > cutoffBin)
            {
                magnitude = 0.0f;
            }

            // Reconstruct the complex number.
            cdata[i] = std::polar(magnitude, phase);
        }
    }
};
