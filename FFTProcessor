#pragma once

#include <JuceHeader.h>
#include <array>
#include <vector>
#include <complex>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <atomic>

//==============================================================================
// FFTProcessor
//
// This header-only class implements an FFT analysis/resynthesis system using
// overlap-add processing with zero padding applied only for frequency interpolation.
// The incoming frame of length fftSize is windowed (using a periodic Hann window),
// then zero padded to paddedSize (a power of 2 >= fftSize) for the FFT; after
// spectral processing and inverse FFT the output is taken as the first fftSize samples,
// rescaled for correct amplitude. Overlap-add with 75% overlap ensures that the windowing
// effects cancel. This design follows the approach in 
// "FFT Processing in JUCE" (https://audiodev.blog/fft-processing/).
//==============================================================================
class FFTProcessor
{
public:
    // FFT configuration constants.
    static constexpr int fftOrder = 10;              // 2^10 = 1024 samples per frame.
    static constexpr int fftSize = 1 << fftOrder;     // 1024 samples per FFT frame.
    static constexpr int numBins = fftSize / 2 + 1;   // 513 frequency bins.
    static constexpr int overlap = 4;               // 75% overlap.
    static constexpr int hopSize = fftSize / overlap; // e.g., 1024/4 = 256 samples per hop.

    // Zero padding: paddedSize is a power of 2 greater than or equal to fftSize.
    // (We use paddedSize solely for increased frequency interpolation.)
    static constexpr int zeroPadOrder = fftOrder + 1;    // e.g., 11 => 2048 padded length.
    static constexpr int paddedSize = 1 << zeroPadOrder;  // 2048 samples.
    static constexpr int paddedNumBins = paddedSize / 2 + 1; // Frequency bins for padded FFT.

    // Gain correction for the Hann window with 75% overlap.
    // (For a Hann window used twice, the overlap-add sum is ~2/3.)
    static constexpr float windowCorrection = 2.0f / 3.0f;

    // Public interface.
    inline void setSampleRate(float sr)
    {
        currentSampleRate = sr;
    }

    inline void setLowpassCutoff(float freqHz)
    {
        lowpassCutoffFrequency = freqHz;
    }

    FFTProcessor() :
        fft(fftOrder),
        fftPadded(zeroPadOrder),
        currentSampleRate(44100.0f),
        lowpassCutoffFrequency(5000.0f),
        pos(0),
        count(0)
    {
        // Create a periodic Hann window.
        // To get a periodic window (i.e. with zero at the end) use fftSize samples
        // computed with denominator fftSize (not fftSize-1).
        windowTable.resize(fftSize);
        for (int i = 0; i < fftSize; ++i)
        {
            double w = 0.5 * (1.0 - std::cos((2.0 * M_PI * i) / static_cast<double>(fftSize)));
            windowTable[i] = static_cast<float>(w);
        }

        // Initialize FIFOs.
        inputFifo.fill(0.0f);
        outputFifo.fill(0.0f);

        // Allocate working buffers.
        fftData.resize(fftSize * 2, 0.0f);
        paddedData.resize(paddedSize * 2, 0.0f);
    }

    inline void reset()
    {
        count.store(0, std::memory_order_relaxed);
        pos.store(0, std::memory_order_relaxed);
        inputFifo.fill(0.0f);
        outputFifo.fill(0.0f);
    }

    // processSample() is called per-sample. It writes incoming samples into a circular FIFO
    // and, every hopSize samples, processes an FFT frame and overlap-adds the output.
    inline float processSample(float sample, bool bypassed)
    {
        int p = pos.load(std::memory_order_relaxed);
        inputFifo[p] = sample;
        float outSample = outputFifo[p];
        outputFifo[p] = 0.0f;

        p = (p + 1) & (fftSize - 1);
        pos.store(p, std::memory_order_relaxed);

        int c = count.load(std::memory_order_relaxed) + 1;
        if (c >= hopSize)
        {
            c = 0;
            processFrame(bypassed);
        }
        count.store(c, std::memory_order_relaxed);
        return outSample;
    }

    inline std::vector<float> flushRemaining(bool bypassed)
    {
        std::vector<float> flushed;
        flushed.reserve(fftSize);
        for (int i = 0; i < fftSize; ++i)
            flushed.push_back(processSample(0.0f, bypassed));
        return flushed;
    }

private:
    // JUCE FFT objects.
    juce::dsp::FFT fft;         // FFT for fftSize (order = fftOrder)
    juce::dsp::FFT fftPadded;   // FFT for paddedSize (order = zeroPadOrder)

    // Precomputed window.
    std::vector<float> windowTable;

    // Circular FIFOs.
    std::array<float, fftSize> inputFifo{};
    std::array<float, fftSize> outputFifo{};

    // Working buffers.
    std::vector<float> fftData;      // Length: fftSize * 2 (real/imag interleaved)
    std::vector<float> paddedData;   // Length: paddedSize * 2

    // Internal counters.
    std::atomic<int> count;  // Samples collected for current hop.
    std::atomic<int> pos;    // Current index in the FIFOs.

    // Parameters.
    float currentSampleRate;
    float lowpassCutoffFrequency;

    // frequencyToBin() converts a frequency in Hz to a bin index for the padded FFT.
    inline int frequencyToBin(float frequency) const
    {
        int bin = static_cast<int>((frequency * paddedSize) / currentSampleRate + 0.5f);
        return std::min(bin, paddedNumBins - 1);
    }

    // multiplyWindow() applies the precomputed window to the first fftSize samples of the buffer.
    inline void multiplyWindow(float* data, int n)
    {
        juce::FloatVectorOperations::multiply(data, windowTable.data(), n);
    }

    // processFrame() performs FFT processing on one frame.
    // It copies the current fftSize samples from the circular input FIFO into fftData,
    // applies the window, zero pads intelligently (without altering the active frame),
    // then (if not bypassed) performs FFT -> processSpectrum -> IFFT.
    // Finally, it applies a second window and gain correction before overlap-add.
    inline void processFrame(bool bypassed)
    {
        // Copy fftSize samples from circular input FIFO into fftData.
        const float* inPtr = inputFifo.data();
        float* fptr = fftData.data();
        int p = pos.load(std::memory_order_relaxed);
        int firstPart = fftSize - p;
        std::memcpy(fptr, inPtr + p, firstPart * sizeof(float));
        if (p > 0)
            std::memcpy(fptr + firstPart, inPtr, p * sizeof(float));

        // Copy the active frame (fftSize samples) into the padded buffer.
        // First, copy the fftData into paddedData.
        std::memcpy(paddedData.data(), fptr, fftSize * sizeof(float));
        // Now zero-pad the remainder.
        std::fill(paddedData.begin() + fftSize, paddedData.end(), 0.0f);

        // Apply window to the active fftData in paddedData.
        multiplyWindow(paddedData.data(), fftSize);

        // (Optional) For zero padding to not introduce abrupt discontinuities, you
        // might also apply a very short taper in the padded region. However, here we
        // assume that our active region is exactly fftSize and the zeros beyond do not
        // affect the IFFT result because we only use the first fftSize samples after IFFT.

        if (!bypassed)
        {
            // Forward FFT on paddedData.
            fftPadded.performRealOnlyForwardTransform(paddedData.data(), true);
            // Process the spectrum: for example, lowpass by zeroing bins above cutoff.
            processSpectrum(paddedData.data(), paddedNumBins);
            // Inverse FFT.
            fftPadded.performRealOnlyInverseTransform(paddedData.data());
            // JUCE's inverse transform divides by paddedSize.
        }

        // Apply the window again to the active region and correct the gain.
        multiplyWindow(paddedData.data(), fftSize);
        juce::FloatVectorOperations::multiply(paddedData.data(), paddedData.data(), windowCorrection, fftSize);

        // Overlap-add: add the first fftSize samples of paddedData into outputFifo.
        // The overlap-add position is determined by p.
        if (p > 0)
            juce::FloatVectorOperations::add(outputFifo.data(), paddedData.data() + fftSize - p, p);
        int remaining = fftSize - p;
        if (remaining > 0)
            juce::FloatVectorOperations::add(outputFifo.data() + p, paddedData.data(), remaining);
    }

    // processSpectrum() applies a lowpass filter by zeroing out frequency bins above cutoff.
    inline void processSpectrum(float* data, int nBins)
    {
        auto* cdata = reinterpret_cast<std::complex<float>*>(data);
        int cutoffBin = frequencyToBin(lowpassCutoffFrequency);
        // A simple method: zero bins above cutoff.
        for (int i = 0; i < nBins; ++i)
        {
            float mag = std::abs(cdata[i]);
            float phase = std::arg(cdata[i]);
            if (i > cutoffBin)
                mag = 0.0f;
            cdata[i] = std::polar(mag, phase);
        }
    }
};
