#pragma once
#include <JuceHeader.h>
#include <vector>
#include <cmath>
#include <algorithm>
#include <array>

namespace project {
    using namespace juce;
    using namespace hise;
    using namespace scriptnode;

    namespace FunctionsClasses {

        // Policy for delay attributes
        struct DefaultDelayPolicy {
            static constexpr float baseDelayMs = 10.f;   // compile-time delay (ms)
            static constexpr float maxDelayMs = 50.f;      // maximum delay time (ms)
        };

        // Policy for modulator attributes – note that now we only use modDepth.
        struct DefaultModulatorPolicy {
            static constexpr float lfoFrequency = 1.9128f; // Default LFO frequency (Hz) for LFO objects.
            static constexpr float modDepth = 0.3f;          // modulation depth (used in allpass filter)
        };

        // Policy for coefficient (all compile-time)
        struct DefaultCoefficientPolicy {
            static constexpr float value = 0.5f;           // fixed coefficient value
        };

        //-----------------------------------------------------------------------------
        // LFO class – computes a modulation value once per sample.
        //-----------------------------------------------------------------------------
        class LFO {
        public:
            LFO(float frequency = DefaultModulatorPolicy::lfoFrequency)
                : frequency(frequency), phase(0.f), sampleRate(44100.f) {
            }

            // Prepare with the current sample rate.
            void prepare(float sr) {
                sampleRate = sr;
                phase = 0.f;
                increment = frequency / sampleRate;
            }

            // Update the LFO state and return the modulated value.
            inline float update() {
                phase += increment;
                if (phase >= 1.f)
                    phase -= 1.f;
                return parSin(phase);
            }

        private:
            float frequency;
            float phase;
            float increment;
            float sampleRate;

            // A parabolic sine approximation.
            inline float parSin(float ph) {
                float shifted = 0.5f - ph;
                return shifted * (8.f - 16.f * std::fabs(shifted));
            }
        };

        //-----------------------------------------------------------------------------
        // Templated compile-time Allpass Delay Line (modified to use external LFO modulation)
        //-----------------------------------------------------------------------------
        template <typename DelayPolicy = DefaultDelayPolicy,
            typename ModulatorPolicy = DefaultModulatorPolicy, // Only modDepth is used.
            typename CoefficientPolicy = DefaultCoefficientPolicy>
        class AllpassDelayLine {
        public:
            AllpassDelayLine()
                : sampleRate(44100.f),
                smoothedDelay(DelayPolicy::baseDelayMs),
                smoothedCoeff(CoefficientPolicy::value),
                writeIndex(0),
                factorDelay(44.1f),
                powerBufferSize(0),
                indexMask(0)
            {
            }

            ~AllpassDelayLine() = default;
            AllpassDelayLine(const AllpassDelayLine&) = delete;
            AllpassDelayLine& operator=(const AllpassDelayLine&) = delete;

            // Prepare the delay line with the given sample rate.
            void prepare(float sr) {
                sampleRate = sr;
                smoothedDelay = DelayPolicy::baseDelayMs;
                smoothedCoeff = CoefficientPolicy::value;
                writeIndex = 0;
                factorDelay = sampleRate / 1000.f;
                int reqSize = static_cast<int>(std::ceil(DelayPolicy::maxDelayMs * factorDelay)) + 4;
                powerBufferSize = nextPow2(reqSize);
                indexMask = powerBufferSize - 1;
                delayBuffer.resize(powerBufferSize, 0.f);
            }

            // Reset the delay line.
            void reset() {
                std::fill(delayBuffer.begin(), delayBuffer.end(), 0.f);
                writeIndex = 0;
                smoothedDelay = DelayPolicy::baseDelayMs;
                smoothedCoeff = CoefficientPolicy::value;
            }

            // Process a single sample through the allpass filter using an external LFO mod value.
            inline float processSample(float x, float modValue) {
                // Compute the modulated coefficient.
                float targetCoeff = CoefficientPolicy::value + ModulatorPolicy::modDepth * modValue;
                // Clamp to avoid instability.
                targetCoeff = (targetCoeff < -0.99f) ? -0.99f : ((targetCoeff > 0.99f) ? 0.99f : targetCoeff);
                static constexpr float smoothingFactor = 0.01f;
                float oneMinusSmooth = 1.f - smoothingFactor;
                smoothedCoeff = oneMinusSmooth * smoothedCoeff + smoothingFactor * targetCoeff;
                smoothedDelay = oneMinusSmooth * smoothedDelay + smoothingFactor * DelayPolicy::baseDelayMs;

                // Compute fractional delay.
                float D = smoothedDelay * factorDelay;
                int d_int = static_cast<int>(D);
                float d_frac = D - static_cast<float>(d_int);
                bool hasFraction = (d_frac > 0.f);
                int offset = hasFraction ? 1 : 0;
                int index0 = (writeIndex - d_int - offset) & indexMask;
                float frac = hasFraction ? (1.f - d_frac) : 0.f;
                int index1 = (index0 + 1) & indexMask;
                float delayedV = (1.f - frac) * delayBuffer[index0] + frac * delayBuffer[index1];

                // Allpass equations.
                float v = x - smoothedCoeff * delayedV;
                float y = smoothedCoeff * v + delayedV;

                delayBuffer[writeIndex] = v;
                writeIndex = (writeIndex + 1) & indexMask;

                return y;
            }

        private:
            // Compute next power of two (for efficient buffer sizing).
            static int nextPow2(int x) {
                x--;
                x |= x >> 1;
                x |= x >> 2;
                x |= x >> 4;
                x |= x >> 8;
                x |= x >> 16;
                return x + 1;
            }

            float sampleRate;
            float smoothedDelay;
            float smoothedCoeff;
            std::vector<float> delayBuffer;
            int writeIndex;
            float factorDelay;
            int powerBufferSize;
            int indexMask;
        };

        //-----------------------------------------------------------------------------
        // Templated Modular Reverb class that chains multiple AllpassDelayLine filters
        // and assigns external LFOs at compile-time via a mapping array.
        // The mapping (an std::array of size NumStages) specifies for each filter the index of the LFO to use.
        //-----------------------------------------------------------------------------
        template <size_t NumStages, size_t NumLFOs,
            const std::array<size_t, NumStages>& LFOMap,
            typename AllpassFilter = AllpassDelayLine<DefaultDelayPolicy, DefaultModulatorPolicy, DefaultCoefficientPolicy>>
            class ModularReverb {
            public:
                ModularReverb() : sampleRate(44100.f) {}

                // Prepare both the allpass filters and the LFOs.
                void prepare(float sr) {
                    sampleRate = sr;
                    for (auto& filter : filters)
                        filter.prepare(sr);
                    for (auto& lfo : lfos)
                        lfo.prepare(sr);
                }

                // Reset the allpass filters.
                void reset() {
                    for (auto& filter : filters)
                        filter.reset();
                }

                // Process a single sample.
                inline float processSample(float x) {
                    std::array<float, NumLFOs> lfoValues;
                    for (size_t i = 0; i < NumLFOs; ++i)
                        lfoValues[i] = lfos[i].update();
                    float y = x;
                    for (size_t i = 0; i < NumStages; ++i) {
                        size_t lfoIndex = LFOMap[i];
                        y = filters[i].processSample(y, lfoValues[lfoIndex]);
                    }
                    return y;
                }

            private:
                float sampleRate;
                std::array<AllpassFilter, NumStages> filters;
                std::array<LFO, NumLFOs> lfos;
        };

    } // namespace FunctionsClasses

    //-----------------------------------------------------------------------------
    // Griffin_Reverb Node Definition Integrating the Optimized Modular Reverb
    // with Mono Summing for Fake Stereo Reverb Processing.
    //-----------------------------------------------------------------------------
    // For testing, we use a single-stage, single-LFO configuration.
    constexpr std::array<size_t, 1> singleStageLFOMap = { 0 };

    template <int NV, size_t NumStages = 1, size_t NumLFOs = 1>
    struct Griffin_Reverb : public data::base {
        SNEX_NODE(Griffin_Reverb);

        struct MetadataClass {
            SN_NODE_ID("Griffin_Reverb");
        };

        static constexpr bool isModNode() { return false; }
        static constexpr bool isPolyphonic() { return NV > 1; }
        static constexpr bool hasTail() { return false; }
        static constexpr bool isSuspendedOnSilence() { return false; }
        static constexpr int getFixChannelAmount() { return 2; }

        static constexpr int NumTables = 0;
        static constexpr int NumSliderPacks = 0;
        static constexpr int NumAudioFiles = 0;
        static constexpr int NumFilters = 0;
        static constexpr int NumDisplayBuffers = 0;

        // AudioReverb class replacing the old AudioEffect.
        class AudioReverb {
        public:
            AudioReverb() : sampleRate(44100.f) {}

            // Prepare the reverb.
            void prepare(double sr) {
                sampleRate = sr;
                reverb.prepare(static_cast<float>(sampleRate));
            }

            // Process an audio buffer sample-by-sample.
            inline void process(float* samples, int numSamples) {
                for (int i = 0; i < numSamples; ++i)
                    samples[i] = reverb.processSample(samples[i]);
            }

            void reset() {
                reverb.reset();
            }
        private:
            double sampleRate;
            // Instantiate the ModularReverb with the single-stage mapping.
            FunctionsClasses::ModularReverb<NumStages, NumLFOs, singleStageLFOMap> reverb;
        };

        // Use a single AudioReverb instance for mono processing.
        AudioReverb monoReverb;
        // Pre-allocated mono buffer sized to the maximum block size.
        std::vector<float> monoBuffer;

        void prepare(PrepareSpecs specs) {
            float sampleRate = specs.sampleRate;
            monoReverb.prepare(sampleRate);
            monoBuffer.resize(static_cast<size_t>(specs.blockSize));
        }

        void reset() {
            monoReverb.reset();
        }

        template <typename ProcessDataType>
        void process(ProcessDataType& data) {
            auto& fixData = data.template as<ProcessData<getFixChannelAmount()>>();
            auto audioBlock = fixData.toAudioBlock();
            auto* leftChannelData = audioBlock.getChannelPointer(0);
            auto* rightChannelData = audioBlock.getChannelPointer(1);
            int blockSize = data.getNumSamples();

            // Sum left and right channels into monoBuffer.
            FloatVectorOperations::copy(monoBuffer.data(), leftChannelData, blockSize);
            FloatVectorOperations::add(monoBuffer.data(), rightChannelData, blockSize);
            FloatVectorOperations::multiply(monoBuffer.data(), 0.5f, blockSize);

            // Process the mono buffer.
            monoReverb.process(monoBuffer.data(), blockSize);

            // Write the processed mono signal back to both channels.
            FloatVectorOperations::copy(leftChannelData, monoBuffer.data(), blockSize);
            FloatVectorOperations::copy(rightChannelData, monoBuffer.data(), blockSize);
        }

        // No runtime parameters for coefficient.
        void createParameters(ParameterDataList& data) {
        }

        void handleHiseEvent(HiseEvent& e) {
        }

        template <typename FrameDataType>
        void processFrame(FrameDataType& data) {
        }
    };

} // namespace project
