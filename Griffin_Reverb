#pragma once
#include <JuceHeader.h>
#include <vector>
#include <cmath>
#include <algorithm>
#include <array>
#include <tuple>
#include <utility>

namespace project {

    //--------------------------------------------------------------------------
    // Macros to simplify configuration type definitions.
    //--------------------------------------------------------------------------
#define DEFINE_LFO_CONFIG_TYPE(name, freq) \
    struct name { \
        static constexpr float frequency = freq; \
    }

#define DEFINE_STAGE_CONFIG_TYPE(name, baseDelay, maxDelay, coeff, dep, lfoIdx) \
    struct name { \
        static constexpr float baseDelayMs = baseDelay; \
        static constexpr float maxDelayMs = maxDelay; \
        static constexpr float coefficient = coeff; \
        static constexpr float depth = dep; \
        static constexpr size_t lfoIndex = lfoIdx; \
    }

//--------------------------------------------------------------------------
// LFOCustom: A compile-time LFO class parameterized by a config type.
//--------------------------------------------------------------------------
    template <typename Config>
    class LFOCustom {
    public:
        LFOCustom() : phase(0.f), sampleRate(44100.f) {}
        void prepare(float sr) {
            sampleRate = sr;
            phase = 0.f;
            increment = Config::frequency / sampleRate;
        }
        inline float update() {
            phase += increment;
            if (phase >= 1.f)
                phase -= 1.f;
            return parSin(phase);
        }
    private:
        float phase;
        float increment;
        float sampleRate;
        inline float parSin(float ph) const {
            float shifted = 0.5f - ph;
            return shifted * (8.f - 16.f * std::fabs(shifted));
        }
    };

    //--------------------------------------------------------------------------
    // AllpassDelayLineCustom: A compile-time allpass delay line class
    // parameterized by a stage config type.
    //--------------------------------------------------------------------------
    template <typename Config>
    class AllpassDelayLineCustom {
    public:
        static constexpr float baseDelayMs = Config::baseDelayMs;
        static constexpr float maxDelayMs = Config::maxDelayMs;
        static constexpr float coefficient = Config::coefficient;
        static constexpr float depth = Config::depth;
        static constexpr size_t lfoIndex = Config::lfoIndex;

        AllpassDelayLineCustom()
            : sampleRate(44100.f),
            smoothedDelay(Config::baseDelayMs),
            smoothedCoeff(Config::coefficient),
            writeIndex(0),
            factorDelay(44.1f),
            powerBufferSize(0),
            indexMask(0)
        {
        }
        void prepare(float sr) {
            sampleRate = sr;
            smoothedDelay = Config::baseDelayMs;
            smoothedCoeff = Config::coefficient;
            writeIndex = 0;
            factorDelay = sampleRate / 1000.f;
            int reqSize = static_cast<int>(std::ceil(Config::maxDelayMs * factorDelay)) + 4;
            powerBufferSize = nextPow2(reqSize);
            indexMask = powerBufferSize - 1;
            delayBuffer.resize(powerBufferSize, 0.f);
        }
        void reset() {
            std::fill(delayBuffer.begin(), delayBuffer.end(), 0.f);
            writeIndex = 0;
            smoothedDelay = Config::baseDelayMs;
            smoothedCoeff = Config::coefficient;
        }
        inline float processSample(float x, float lfoValue) {
            float targetCoeff = Config::coefficient + Config::depth * lfoValue;
            targetCoeff = (targetCoeff < -0.99f) ? -0.99f : ((targetCoeff > 0.99f) ? 0.99f : targetCoeff);
            static const float smoothingFactor = 0.01f;
            float oneMinusSmooth = 1.f - smoothingFactor;
            smoothedCoeff = oneMinusSmooth * smoothedCoeff + smoothingFactor * targetCoeff;
            smoothedDelay = oneMinusSmooth * smoothedDelay + smoothingFactor * Config::baseDelayMs;

            float D = smoothedDelay * factorDelay;
            int d_int = static_cast<int>(D);
            float d_frac = D - static_cast<float>(d_int);
            bool hasFraction = (d_frac > 0.f);
            int offset = hasFraction ? 1 : 0;
            int index0 = (writeIndex - d_int - offset) & indexMask;
            float frac = hasFraction ? (1.f - d_frac) : 0.f;
            int index1 = (index0 + 1) & indexMask;
            float delayedV = (1.f - frac) * delayBuffer[index0] + frac * delayBuffer[index1];

            float v = x - smoothedCoeff * delayedV;
            float y = smoothedCoeff * v + delayedV;

            delayBuffer[writeIndex] = v;
            writeIndex = (writeIndex + 1) & indexMask;
            return y;
        }
    private:
        static int nextPow2(int x) {
            x--;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            return x + 1;
        }
        float sampleRate;
        float smoothedDelay;
        float smoothedCoeff;
        std::vector<float> delayBuffer;
        int writeIndex;
        float factorDelay;
        int powerBufferSize;
        int indexMask;
    };

    //--------------------------------------------------------------------------
    // Helper structures to group configuration packs into single types.
    //--------------------------------------------------------------------------
    template <typename... LFOConfigTypes>
    struct LFOConfigs {
        using tuple_type = std::tuple<LFOCustom<LFOConfigTypes>...>;
    };

    template <typename... StageConfigTypes>
    struct StageConfigs {
        using tuple_type = std::tuple<AllpassDelayLineCustom<StageConfigTypes>...>;
    };

    //--------------------------------------------------------------------------
    // ModularReverbCustom: A compile-time reverb that chains together an
    // arbitrary number of stages and LFOs. It takes two type parameters:
    // one for LFO configurations and one for stage configurations.
    //--------------------------------------------------------------------------
    template <typename LFOConfigPack, typename StageConfigPack>
    class ModularReverbCustom {
    public:
        using lfo_tuple_type = typename LFOConfigPack::tuple_type;
        using stage_tuple_type = typename StageConfigPack::tuple_type;
        static constexpr size_t numLFOs = std::tuple_size<lfo_tuple_type>::value;
        static constexpr size_t numStages = std::tuple_size<stage_tuple_type>::value;

        ModularReverbCustom() : sampleRate(44100.f) {}

        void prepare(float sr) {
            sampleRate = sr;
            std::apply([&](auto&... lfo) { ((lfo.prepare(sr)), ...); }, lfos);
            std::apply([&](auto&... stage) { ((stage.prepare(sr)), ...); }, stages);
        }
        void reset() {
            std::apply([&](auto&... stage) { ((stage.reset()), ...); }, stages);
        }
        inline float processSample(float x) {
            std::array<float, numLFOs> lfoValues;
            updateLFOs(lfoValues, std::make_index_sequence<numLFOs>());
            return processStages(x, lfoValues, std::make_index_sequence<numStages>());
        }
    private:
        float sampleRate;
        lfo_tuple_type lfos;
        stage_tuple_type stages;

        template <std::size_t... Is>
        void updateLFOs(std::array<float, numLFOs>& values, std::index_sequence<Is...>) {
            ((values[Is] = std::get<Is>(lfos).update()), ...);
        }

        template <std::size_t I>
        static constexpr size_t getStageLFOIndex() {
            using stage_type = typename std::tuple_element<I, stage_tuple_type>::type;
            return stage_type::lfoIndex;
        }

        template <std::size_t... Is>
        float processStages(float input, const std::array<float, numLFOs>& lfoValues, std::index_sequence<Is...>) {
            float output = input;
            ((output = std::get<Is>(stages).processSample(output, lfoValues[getStageLFOIndex<Is>()])), ...);
            return output;
        }
    };

    //--------------------------------------------------------------------------
    // Griffin_Reverb Node Definition
    //--------------------------------------------------------------------------

    // Define configuration types using the new macros.
    DEFINE_LFO_CONFIG_TYPE(MyLFO1, 1.9128f);
    DEFINE_STAGE_CONFIG_TYPE(MyStage1, 10.f, 50.f, 0.5f, 0.3f, 0);

    template <int NV>
    struct Griffin_Reverb : public data::base {
        SNEX_NODE(Griffin_Reverb);

        struct MetadataClass {
            SN_NODE_ID("Griffin_Reverb");
        };

        static constexpr bool isModNode() { return false; }
        static constexpr bool isPolyphonic() { return NV > 1; }
        static constexpr bool hasTail() { return false; }
        static constexpr bool isSuspendedOnSilence() { return false; }
        static constexpr int getFixChannelAmount() { return 2; }

        static constexpr int NumTables = 0;
        static constexpr int NumSliderPacks = 0;
        static constexpr int NumAudioFiles = 0;
        static constexpr int NumFilters = 0;
        static constexpr int NumDisplayBuffers = 0;

        // AudioReverb class replacing the old AudioEffect.
        class AudioReverb {
        public:
            AudioReverb() : sampleRate(44100.f) {}

            void prepare(double sr) {
                sampleRate = sr;
                reverb.prepare(static_cast<float>(sampleRate));
            }

            inline void process(float* samples, int numSamples) {
                for (int i = 0; i < numSamples; ++i)
                    samples[i] = reverb.processSample(samples[i]);
            }

            void reset() {
                reverb.reset();
            }
        private:
            double sampleRate;
            // Instantiate the ModularReverbCustom with our configuration packs.
            using MyLFOConfigs = LFOConfigs<MyLFO1>;
            using MyStageConfigs = StageConfigs<MyStage1>;
            ModularReverbCustom<MyLFOConfigs, MyStageConfigs> reverb;
        };

        AudioReverb monoReverb;
        std::vector<float> monoBuffer;

        void prepare(PrepareSpecs specs) {
            float sampleRate = specs.sampleRate;
            monoReverb.prepare(sampleRate);
            monoBuffer.resize(static_cast<size_t>(specs.blockSize));
        }

        void reset() {
            monoReverb.reset();
        }

        template <typename ProcessDataType>
        void process(ProcessDataType& data) {
            auto& fixData = data.template as<ProcessData<getFixChannelAmount()>>();
            auto audioBlock = fixData.toAudioBlock();
            auto* leftChannelData = audioBlock.getChannelPointer(0);
            auto* rightChannelData = audioBlock.getChannelPointer(1);
            int blockSize = data.getNumSamples();

            FloatVectorOperations::copy(monoBuffer.data(), leftChannelData, blockSize);
            FloatVectorOperations::add(monoBuffer.data(), rightChannelData, blockSize);
            FloatVectorOperations::multiply(monoBuffer.data(), 0.5f, blockSize);

            monoReverb.process(monoBuffer.data(), blockSize);

            FloatVectorOperations::copy(leftChannelData, monoBuffer.data(), blockSize);
            FloatVectorOperations::copy(rightChannelData, monoBuffer.data(), blockSize);
        }

        void createParameters(ParameterDataList& data) {}
        void handleHiseEvent(HiseEvent& e) {}
        template <typename FrameDataType>
        void processFrame(FrameDataType& data) {}
    };

} // namespace project
