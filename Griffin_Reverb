#pragma once
#include <JuceHeader.h>
#include <vector>
#include <cmath>
#include <algorithm>

namespace project {
    using namespace juce;
    using namespace hise;
    using namespace scriptnode;

    namespace FunctionsClasses {

        // Policy for delay attributes
        struct DefaultDelayPolicy {
            static constexpr float baseDelayMs = 10.f;   // compile-time delay (ms)
            static constexpr float maxDelayMs = 50.f;      // maximum delay time (ms)
        };

        // Policy for modulator attributes
        struct DefaultModulatorPolicy {
            static constexpr float lfoFrequency = 1.9128f; // LFO frequency (Hz)
            static constexpr float modDepth = 0.3f;          // modulation depth
        };

        // Policy for coefficient (all compile-time)
        struct DefaultCoefficientPolicy {
            static constexpr float value = 0.5f;           // fixed coefficient value
        };

        // Templated compile-time Allpass Delay Line using policy classes.
        template <typename DelayPolicy = DefaultDelayPolicy,
            typename ModulatorPolicy = DefaultModulatorPolicy,
            typename CoefficientPolicy = DefaultCoefficientPolicy>
        class AllpassDelayLine {
        public:
            AllpassDelayLine()
                : sampleRate(44100.f),
                smoothedDelay(DelayPolicy::baseDelayMs),
                smoothedCoeff(CoefficientPolicy::value),
                lfoPhase(0.f),
                writeIndex(0),
                factorDelay(44.1f),
                powerBufferSize(0),
                indexMask(0),
                lfoIncrement(0.f)
            {
            }

            ~AllpassDelayLine() = default;
            AllpassDelayLine(const AllpassDelayLine&) = delete;
            AllpassDelayLine& operator=(const AllpassDelayLine&) = delete;

            // Prepare the delay line with the given sample rate.
            // This will compute the internal parameters and resize the buffer.
            void prepare(float sr) {
                sampleRate = sr;
                smoothedDelay = DelayPolicy::baseDelayMs;
                smoothedCoeff = CoefficientPolicy::value;
                lfoPhase = 0.f;
                writeIndex = 0;
                factorDelay = sampleRate / 1000.f;
                lfoIncrement = ModulatorPolicy::lfoFrequency / sampleRate;

                int reqSize = static_cast<int>(std::ceil(DelayPolicy::maxDelayMs * factorDelay)) + 4;
                powerBufferSize = nextPow2(reqSize);
                indexMask = powerBufferSize - 1;
                delayBuffer.resize(powerBufferSize, 0.f);
            }

            // Reset the delay line to its initial state.
            void reset() {
                std::fill(delayBuffer.begin(), delayBuffer.end(), 0.f);
                writeIndex = 0;
                smoothedDelay = DelayPolicy::baseDelayMs;
                smoothedCoeff = CoefficientPolicy::value;
                lfoPhase = 0.f;
            }

            // Process a single sample through the allpass filter.
            inline float processSample(float x) {
                // --- LFO Update and Coefficient Modulation ---
                lfoPhase += lfoIncrement;
                if (lfoPhase >= 1.f)
                    lfoPhase -= 1.f;
                float modValue = parSin(lfoPhase);
                float targetCoeff = CoefficientPolicy::value + ModulatorPolicy::modDepth * modValue;
                // Branchless clamping
                targetCoeff = (targetCoeff < -0.99f) ? -0.99f : ((targetCoeff > 0.99f) ? 0.99f : targetCoeff);
                static constexpr float smoothingFactor = 0.01f;
                float oneMinusSmooth = 1.f - smoothingFactor;
                smoothedCoeff = oneMinusSmooth * smoothedCoeff + smoothingFactor * targetCoeff;
                smoothedDelay = oneMinusSmooth * smoothedDelay + smoothingFactor * DelayPolicy::baseDelayMs;

                // --- Fractional Delay Calculation ---
                float D = smoothedDelay * factorDelay;
                int d_int = static_cast<int>(D);
                float d_frac = D - static_cast<float>(d_int);
                bool hasFraction = (d_frac > 0.f);
                int offset = hasFraction ? 1 : 0;
                int index0 = (writeIndex - d_int - offset) & indexMask;
                float frac = hasFraction ? (1.f - d_frac) : 0.f;
                int index1 = (index0 + 1) & indexMask;
                float delayedV = (1.f - frac) * delayBuffer[index0] + frac * delayBuffer[index1];

                // --- Direct-Form II All-Pass Equations ---
                float v = x - smoothedCoeff * delayedV;
                float y = smoothedCoeff * v + delayedV;

                delayBuffer[writeIndex] = v;
                writeIndex = (writeIndex + 1) & indexMask;

                return y;
            }

        private:
            // Approximated parabolic sine function used for LFO modulation.
            inline float parSin(float ph) {
                float shifted = 0.5f - ph;
                return shifted * (8.f - 16.f * std::fabs(shifted));
            }

            // Compute next power of two (for efficient buffer sizing)
            static int nextPow2(int x) {
                x--;
                x |= x >> 1;
                x |= x >> 2;
                x |= x >> 4;
                x |= x >> 8;
                x |= x >> 16;
                return x + 1;
            }

            float sampleRate;
            float smoothedDelay;
            float smoothedCoeff;
            float lfoPhase;
            std::vector<float> delayBuffer;
            int writeIndex;
            float factorDelay;
            float lfoIncrement;
            int powerBufferSize;
            int indexMask;
        };

    } // namespace FunctionsClasses

    //=============================================================================
    // Griffin_Reverb Node Definition Integrating the Optimized All-Pass Filter
    // with Mono Summing for Fake Stereo Reverb Processing.
    //=============================================================================
    template <int NV>
    struct Griffin_Reverb : public data::base {
        SNEX_NODE(Griffin_Reverb);

        struct MetadataClass {
            SN_NODE_ID("Griffin_Reverb");
        };

        static constexpr bool isModNode() { return false; }
        static constexpr bool isPolyphonic() { return NV > 1; }
        static constexpr bool hasTail() { return false; }
        static constexpr bool isSuspendedOnSilence() { return false; }
        static constexpr int getFixChannelAmount() { return 2; }

        static constexpr int NumTables = 0;
        static constexpr int NumSliderPacks = 0;
        static constexpr int NumAudioFiles = 0;
        static constexpr int NumFilters = 0;
        static constexpr int NumDisplayBuffers = 0;

        // Typedef the compile-time allpass filter using the default policies.
        using AllpassFilterType = FunctionsClasses::AllpassDelayLine<
            FunctionsClasses::DefaultDelayPolicy,
            FunctionsClasses::DefaultModulatorPolicy,
            FunctionsClasses::DefaultCoefficientPolicy>;

        // Single AudioEffect instance for mono processing.
        class AudioEffect {
        public:
            AudioEffect() : sampleRate(44100.f) {}

            // Prepare the audio effect; note that parameters are now compile-time.
            void prepare(double sr) {
                sampleRate = sr;
                allpassFilter.prepare(static_cast<float>(sampleRate));
            }

            // Process an audio buffer in-place.
            inline void process(float* samples, int numSamples) {
                for (int i = 0; i < numSamples; ++i)
                    samples[i] = allpassFilter.processSample(samples[i]);
            }

            void reset() {
                allpassFilter.reset();
            }

        private:
            double sampleRate;
            AllpassFilterType allpassFilter;
        };

        // Use a single AudioEffect instance for mono processing.
        AudioEffect monoEffect;
        // Pre-allocated mono buffer sized to the maximum block size.
        std::vector<float> monoBuffer;

        void prepare(PrepareSpecs specs) {
            float sampleRate = specs.sampleRate;
            monoEffect.prepare(sampleRate);
            // Resize monoBuffer to the maximum expected block size.
            monoBuffer.resize(static_cast<size_t>(specs.blockSize));
        }

        void reset() {
            monoEffect.reset();
        }

        template <typename ProcessDataType>
        void process(ProcessDataType& data) {
            auto& fixData = data.template as<ProcessData<getFixChannelAmount()>>();
            auto audioBlock = fixData.toAudioBlock();
            auto* leftChannelData = audioBlock.getChannelPointer(0);
            auto* rightChannelData = audioBlock.getChannelPointer(1);
            int blockSize = data.getNumSamples();

            // Sum left and right channels into monoBuffer: mono = (left + right) / 2.
            FloatVectorOperations::copy(monoBuffer.data(), leftChannelData, blockSize);
            FloatVectorOperations::add(monoBuffer.data(), rightChannelData, blockSize);
            FloatVectorOperations::multiply(monoBuffer.data(), 0.5f, blockSize);

            // Process the mono buffer through the allpass filter.
            monoEffect.process(monoBuffer.data(), blockSize);

            // Write the processed mono signal back to both channels.
            FloatVectorOperations::copy(leftChannelData, monoBuffer.data(), blockSize);
            FloatVectorOperations::copy(rightChannelData, monoBuffer.data(), blockSize);
        }

        // The runtime coefficient parameter is now removed to enforce compile-time control.
        void createParameters(ParameterDataList& data) {
            // No user parameters for coefficient.
        }

        void handleHiseEvent(HiseEvent& e) {
            // Event handling as needed.
        }

        template <typename FrameDataType>
        void processFrame(FrameDataType& data) {}

    };

} // namespace project
