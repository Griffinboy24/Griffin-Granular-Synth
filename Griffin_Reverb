#pragma once
#include <JuceHeader.h>
#include "src/massivereverb.h" // Include relative to project structure

namespace project
{

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

    using namespace juce;
    using namespace hise;
    using namespace scriptnode;

    namespace FunctionsClasses {
        // Implement functions and classes here
    }

    template <int NV>
    struct Griffin_Reverb : public data::base
    {
        SNEX_NODE(Griffin_Reverb);

        struct MetadataClass
        {
            SN_NODE_ID("Griffin_Reverb");
        };

        //==============================================================================
        // Node Properties 
        //==============================================================================
        static constexpr bool isModNode() { return false; }
        static constexpr bool isPolyphonic() { return NV > 1; }
        static constexpr bool hasTail() { return false; }
        static constexpr bool isSuspendedOnSilence() { return false; }
        static constexpr int getFixChannelAmount() { return 2; }

        static constexpr int NumTables = 0;
        static constexpr int NumSliderPacks = 0;
        static constexpr int NumAudioFiles = 0;
        static constexpr int NumFilters = 0;
        static constexpr int NumDisplayBuffers = 0;

        //==============================================================================
        // Audio Effect Class
        //==============================================================================
        class AudioEffect
        {
        public:
            AudioEffect(float initiaParam = 5000.0f)
                : localParam(initiaParam)
                , reverb() // Using the modular reverb configuration below.
            {
            }

            void prepare(double sampleRate, double blockSize)
            {
                reverb.reset();
                // Update LFO modulators and modulated filters with the current sample rate.
                reverb.setLfoSampleRate(static_cast<float>(sampleRate));
                // Pre-allocate the mono buffer to a default size.
                monoBuffer.resize(blockSize);
            }

            inline void processMono(float* leftChannelData, float* rightChannelData, int numSamples)
            {
                if (monoBuffer.size() < static_cast<size_t>(numSamples))
                    monoBuffer.resize(numSamples);
                FloatVectorOperations::copy(monoBuffer.data(), leftChannelData, numSamples);
                FloatVectorOperations::add(monoBuffer.data(), rightChannelData, numSamples);
                FloatVectorOperations::multiply(monoBuffer.data(), 0.5f, numSamples);
                reverb.processBlock(monoBuffer.data(), numSamples);
                FloatVectorOperations::copy(leftChannelData, monoBuffer.data(), numSamples);
                FloatVectorOperations::copy(rightChannelData, monoBuffer.data(), numSamples);
            }

            void updateParams(float newParam)
            {
                localParam = newParam;
            }

        private:
            float localParam;
            std::vector<float> monoBuffer;
            // Our reverb now uses a single modulated allpass filter.
            using MyReverbType = MyReverb::ModularReverb<float,
                // Uncomment and add more configurations if needed.
                // ALLPASS_CONFIG(277, 0.55f),
                ALLPASS_MOD_CONFIG(500, 0.55f, 0.9128f, 0.0001f)
            >;
            MyReverbType reverb;
        };

        void prepare(PrepareSpecs specs)
        {
            float sampleRate = specs.sampleRate;
            float blockSize = specs.blockSize;
            monoEffect.prepare(sampleRate, blockSize);
        }

        void reset() {}

        template <typename ProcessDataType>
        void process(ProcessDataType& data)
        {
            auto& fixData = data.template as<ProcessData<getFixChannelAmount()>>();
            auto audioBlock = fixData.toAudioBlock();
            auto* leftChannelData = audioBlock.getChannelPointer(0);
            auto* rightChannelData = audioBlock.getChannelPointer(1);
            int blockSize = data.getNumSamples();
            monoEffect.processMono(leftChannelData, rightChannelData, blockSize);
        }

        template <int P>
        void setParameter(double v)
        {
            if (P == 0) {}
            if (P == 1) {}
        }

        void createParameters(ParameterDataList& data)
        {
            {
                parameter::data p("Param", { 20.0, 20000.0, 0.01 });
                registerCallback<0>(p);
                p.setDefaultValue(5000.0);
                data.add(std::move(p));
            }
            {
                parameter::data p("Param2", { 20.0, 20000.0, 0.01 });
                registerCallback<0>(p);
                p.setDefaultValue(5000.0);
                data.add(std::move(p));
            }
        }

        void setExternalData(const ExternalData& ed, int index) {}

        void handleHiseEvent(HiseEvent& e) {}

        template <typename FrameDataType>
        void processFrame(FrameDataType& data) {}

    private:
        AudioEffect monoEffect;
    };

} // namespace project
