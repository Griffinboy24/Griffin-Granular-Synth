#pragma once

#include <JuceHeader.h>
#include <array>
#include <vector>
#include <cmath>
#include <algorithm>
#include <random>
#include <limits>

namespace project
{

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

    using namespace juce;
    using namespace hise;
    using namespace scriptnode;

    //==============================================================================
    // This is a barebones sampler node with polyphony.
    // It retains the SNEX node and templating structure while removing all granular
    // and envelope logic. Playback is done using linear interpolation.
    //==============================================================================

    template <int NV>
    struct Griffin_FFT : public data::base
    {
        SNEX_NODE(Griffin_FFT);
        struct MetadataClass { SN_NODE_ID("Griffin_FFT"); };

        static constexpr bool isModNode() { return true; }
        static constexpr bool isPolyphonic() { return NV > 1; }
        static constexpr bool hasTail() { return false; }
        static constexpr bool isSuspendedOnSilence() { return false; }
        static constexpr int  getFixChannelAmount() { return 2; }

        static constexpr int NumTables = 0;
        static constexpr int NumSliderPacks = 0;
        static constexpr int NumAudioFiles = 1;
        static constexpr int NumFilters = 0;
        static constexpr int NumDisplayBuffers = 0;

        //==============================================================================
        // Voice struct
        // Each voice simply holds its current note, velocity, playback position, and
        // read-increment (delta). Once playback reaches the end of the sample, the voice
        // is deactivated.
        //==============================================================================
        struct Voice
        {
            int   midiNote = 60;
            bool  isActive = false;
            float velocity = 1.0f;

            // Playback state:
            double position = 0.0;   // current (fractional) read position in samples
            double delta = 1.0;      // read increment per output sample

            // Reset the voice on note-on.
            // @param note         MIDI note number.
            // @param vel          Note velocity.
            // @param startPos     Start position (in samples) in the loaded sample.
            // @param readDelta    Read increment computed from pitch settings.
            void reset(int note, float vel, double startPos, double readDelta)
            {
                midiNote = note;
                velocity = vel;
                position = startPos;
                delta = readDelta;
                isActive = true;
            }
        };

        //==============================================================================
        // Member variables
        //==============================================================================
        PolyData<Voice, NV> voices;
        ExternalData sampleData;
        AudioBuffer<float> sampleBuffer;
        std::array<const float*, 2> sample{ nullptr, nullptr };

        std::array<float, 128> pitchRatios{};  // precomputed pitch factors
        double sampleRate = 44100.0;
        // sampleRateRatio is computed from the file sample rate (stored in sampleData.sampleRate)
        double sampleRateRatio = 1.0;

        // Parameters
        // p0: Pitch offset (in semitones)
        // p1: Playhead Position (0.0 to 1.0; fraction of sample length)
        // p2: Overall gain (0.0 to 1.0)
        double pitchOffsetSemitones = 0.0;
        float playheadPosition = 0.0f;
        float gain = 1.0f;

        // Optimized reflection function (for wrapping playhead positions, if desired)
        inline static float reflectOffset(float offset, float bufferLen)
        {
            const float doubleLen = 2.0f * bufferLen;
            if (offset > -doubleLen && offset < doubleLen)
            {
                if (offset < 0.0f)
                    offset += doubleLen;
            }
            else
            {
                offset = std::fmod(offset, doubleLen);
                if (offset < 0.0f)
                    offset += doubleLen;
            }
            if (offset > bufferLen)
                offset = doubleLen - offset;
            return offset;
        }

        //==============================================================================
        // prepare(): Called during initialization.
        //==============================================================================
        void prepare(PrepareSpecs specs)
        {
            sampleRate = specs.sampleRate;
            initPitchRatios();
            voices.prepare(specs);
        }

        //==============================================================================
        // updateDerivedParameters(): Update any parameters that depend on sample rate
        // or external data.
        //==============================================================================
        void updateDerivedParameters()
        {
            sampleRateRatio = (sampleData.sampleRate > 0 ? sampleData.sampleRate : 44100.0) / sampleRate;
        }

        //==============================================================================
        // setExternalData(): Called when a new audio file is loaded.
        //==============================================================================
        void setExternalData(const ExternalData& ed, int /*index*/)
        {
            sampleData = ed;
            AudioSampleBuffer tempBuffer = ed.toAudioSampleBuffer();
            int numSamples = tempBuffer.getNumSamples();
            int numChannels = tempBuffer.getNumChannels();

            if (numSamples <= 0)
            {
                static AudioBuffer<float> safetyBuffer(2, 4);
                safetyBuffer.clear();
                sampleBuffer.makeCopyOf(safetyBuffer, true);
            }
            else
            {
                sampleBuffer.makeCopyOf(tempBuffer, true);
            }
            sample[0] = sampleBuffer.getReadPointer(0);
            if (numChannels > 1)
                sample[1] = sampleBuffer.getReadPointer(1);
            else
                sample[1] = sample[0];

            updateDerivedParameters();
        }

        //==============================================================================
        // handleHiseEvent(): Trigger a note (note-on event).
        // Here we simply grab a voice and reset it.
        //==============================================================================
        void handleHiseEvent(HiseEvent& e)
        {
            if (e.isNoteOn())
            {
                auto& voice = voices.get();
                // Determine the starting read position based on the playheadPosition parameter.
                int currentSampleLength = sampleBuffer.getNumSamples();
                if (currentSampleLength < 1)
                    currentSampleLength = 1;
                double startPos = playheadPosition * (currentSampleLength - 1);

                // Compute the read increment (delta) using the pitch ratio for the note,
                // the global pitch offset (in semitones) and the sample rate ratio.
                double baseDelta = pitchRatios[e.getNoteNumber()] * sampleRateRatio;
                double globalFactor = std::pow(2.0, pitchOffsetSemitones / 12.0);
                double readDelta = baseDelta * globalFactor;

                voice.reset(e.getNoteNumber(), e.getFloatVelocity(), startPos, readDelta);
            }
        }

        //==============================================================================
        // process(): Called per audio block.
        // For each active voice, we perform linear interpolation read from the sample.
        //==============================================================================
        template <typename ProcessDataType>
        void process(ProcessDataType& data)
        {
            DataReadLock sl(this->sampleData);
            auto& fixData = data.template as<ProcessData<getFixChannelAmount()>>();
            auto audioBlock = fixData.toAudioBlock();
            auto* leftChannel = audioBlock.getChannelPointer(0);
            auto* rightChannel = audioBlock.getChannelPointer(1);
            int totalSamples = data.getNumSamples();

            if (sampleBuffer.getNumSamples() == 0)
            {
                audioBlock.clear();
                return;
            }

            // Clear output block
            std::fill(leftChannel, leftChannel + totalSamples, 0.0f);
            std::fill(rightChannel, rightChannel + totalSamples, 0.0f);

            const int sampleLen = sampleBuffer.getNumSamples();

            // Process each voice
            for (auto& voice : voices)
            {
                if (!voice.isActive)
                    continue;

                // Process the entire block for this voice.
                for (int i = 0; i < totalSamples; ++i)
                {
                    // If we have reached (or passed) the end of the sample, stop playback.
                    if (voice.position >= sampleLen - 1)
                    {
                        voice.isActive = false;
                        break;
                    }

                    // Linear interpolation:
                    int idx = static_cast<int>(voice.position);
                    float frac = static_cast<float>(voice.position - idx);
                    float sampleL = sample[0][idx] + frac * (sample[0][(idx + 1 < sampleLen ? idx + 1 : sampleLen - 1)] - sample[0][idx]);
                    float sampleR = sample[1][idx] + frac * (sample[1][(idx + 1 < sampleLen ? idx + 1 : sampleLen - 1)] - sample[1][idx]);

                    // Write to output with voice velocity and overall gain.
                    leftChannel[i] += sampleL * voice.velocity * gain;
                    rightChannel[i] += sampleR * voice.velocity * gain;

                    voice.position += voice.delta;
                }
            }
        }

        //==============================================================================
        // createParameters(): Set up parameters (p0: pitch offset, p1: playhead, p2: gain)
        //==============================================================================
        void createParameters(ParameterDataList& data)
        {
            {
                parameter::data pitchOffsetParam("Pitch (semitones)", { -24.0, 24.0, 0.01 });
                registerCallback<0>(pitchOffsetParam);
                pitchOffsetParam.setDefaultValue(0.0);
                data.add(std::move(pitchOffsetParam));
            }
            {
                parameter::data playheadParam("Playhead Position", { 0.0, 1.0, 0.001 });
                registerCallback<1>(playheadParam);
                playheadParam.setDefaultValue(0.0);
                data.add(std::move(playheadParam));
            }
            {
                parameter::data gainParam("Gain", { 0.0, 1.0, 0.01 });
                registerCallback<2>(gainParam);
                gainParam.setDefaultValue(1.0);
                data.add(std::move(gainParam));
            }
        }

        //==============================================================================
        // Parameter callback: setParameter<P>
        //==============================================================================
        template <int P>
        void setParameter(double v)
        {
            if constexpr (P == 0)
            {
                pitchOffsetSemitones = v;
            }
            else if constexpr (P == 1)
            {
                playheadPosition = (float)v;
            }
            else if constexpr (P == 2)
            {
                gain = (float)v;
            }
        }

        //==============================================================================
        // initPitchRatios(): Precompute a table of pitch ratios for MIDI note numbers.
        //==============================================================================
        void initPitchRatios()
        {
            for (int i = 0; i < 128; ++i)
                pitchRatios[i] = std::pow(2.0f, (float)(i - 60) / 12.0f);
        }



        template <typename FrameDataType>
        void processFrame(FrameDataType& /*data*/)
        {
        }
        void reset()
        {
        }


    };

} // namespace project
