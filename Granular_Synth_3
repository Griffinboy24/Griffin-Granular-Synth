#pragma once

#include <JuceHeader.h>
#include <array>
#include <vector>
#include <cmath>
#include <algorithm>
#include <random>
#include <limits>

namespace project
{

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

    using namespace juce;
    using namespace hise;
    using namespace scriptnode;

    //==============================================================================
    // EnvelopeMode: (for clarity in the struct; runtime shape is chosen via function pointers)
    //==============================================================================
    enum class EnvelopeMode
    {
        Parabolic,
        Triangle,
        ASR // new (Punchy is treated as a modifier)
    };

    //==============================================================================
    // GrainEssence: Randomized per-grain parameters computed on activation.
    //==============================================================================
    struct GrainEssence
    {
        double pitchOffsetCents = 0.0;
        float  volumeMult = 1.0f;
        float  panning = 0.0f;
        int    gapAdjustment = 0;
        float  sizeMult = 1.0f;
        float  startOffsetInSamples = 0.0f;
    };

    //==============================================================================
    // Envelope state structs
    //==============================================================================

    //---------------------------------------------------------------
    // Parabolic envelope state
    //---------------------------------------------------------------
    struct ParabolicEnvelopeState
    {
        float amplitude = 0.0f;
        float slope = 0.0f;
        float curve = 0.0f;
        bool  finished = false;

        int   totalSamples = 0;
        int   samplesDone = 0;

        bool  isPunchy = false;
        int   segmentIndex = 0;
        int   nextBoundary = 0;
        float finalAmplitude = 0.0f;  // For punchy mode

        void initNormal(float gA, int durSamples)
        {
            finished = false;
            totalSamples = durSamples;
            samplesDone = 0;
            isPunchy = false;
            segmentIndex = 0;

            if (durSamples < 1)
            {
                amplitude = 0.0f;
                slope = 0.0f;
                curve = 0.0f;
                finished = true;
                return;
            }

            amplitude = 0.0f;
            double rdur = 1.0 / double(durSamples);
            double rdur2 = rdur * rdur;
            slope = float(4.0 * double(gA) * (rdur - rdur2));
            curve = float(-8.0 * double(gA) * rdur2);
            nextBoundary = durSamples; // single segment
        }

        void initPunchy(float gA, int durSamples)
        {
            finished = false;
            totalSamples = durSamples;
            samplesDone = 0;
            isPunchy = true;
            segmentIndex = 0;
            finalAmplitude = gA;

            if (durSamples < 2)
            {
                amplitude = 0.0f;
                slope = 0.0f;
                curve = 0.0f;
                finished = true;
                return;
            }

            int half = durSamples / 2;
            if (half < 1) half = 1;

            amplitude = gA;  // hold at full amplitude
            slope = 0.0f;
            curve = 0.0f;
            nextBoundary = half;
        }

        inline void advanceSegment()
        {
            if (!isPunchy)
            {
                finished = true;
                return;
            }
            if (segmentIndex == 0)
            {
                segmentIndex = 1;
                int half = totalSamples - (totalSamples / 2);
                if (half < 1)
                {
                    finished = true;
                    return;
                }
                const float H = (float)half;
                slope = -finalAmplitude / (H * H);
                curve = -(2.0f * finalAmplitude) / (H * H);
                nextBoundary = half;
            }
            else
            {
                finished = true;
            }
        }
    };

    //---------------------------------------------------------------
    // Linear (Triangle) envelope state
    //---------------------------------------------------------------
    struct LinearEnvelopeState
    {
        float amplitude = 0.0f;
        float slope = 0.0f;
        bool  finished = false;
        bool  isPunchy = false;
        int   segmentIndex = 0;

        int   totalSamples = 0;
        int   samplesDone = 0;
        int   nextBoundary = 0;

        float grainAmp = 0.0f; // final amplitude

        void initNormal(float gA, int durSamples)
        {
            finished = false;
            isPunchy = false;
            segmentIndex = 0;
            totalSamples = durSamples;
            samplesDone = 0;
            grainAmp = gA;

            if (durSamples < 2)
            {
                amplitude = 0.f;
                slope = 0.f;
                finished = true;
                return;
            }

            int half = durSamples / 2;
            if (half < 1) half = 1;
            amplitude = 0.f;
            slope = gA / (float)half;
            nextBoundary = half;
        }

        void initPunchy(float gA, int durSamples)
        {
            finished = false;
            isPunchy = true;
            segmentIndex = 0;
            totalSamples = durSamples;
            samplesDone = 0;
            grainAmp = gA;

            if (durSamples < 2)
            {
                amplitude = 0.f;
                slope = 0.f;
                finished = true;
                return;
            }

            int half = durSamples / 2;
            if (half < 1) half = 1;
            amplitude = gA;
            slope = 0.f;
            nextBoundary = half;
        }

        inline void advanceSegment()
        {
            if (!isPunchy)
            {
                if (segmentIndex == 0)
                {
                    segmentIndex = 1;
                    int half = totalSamples - (totalSamples / 2);
                    if (half < 1)
                    {
                        finished = true;
                        return;
                    }
                    amplitude = grainAmp;
                    slope = (0.f - grainAmp) / (float)half;
                    nextBoundary = half;
                }
                else
                {
                    finished = true;
                }
            }
            else
            {
                if (segmentIndex == 0)
                {
                    segmentIndex = 1;
                    int half = totalSamples - (totalSamples / 2);
                    if (half < 1)
                    {
                        finished = true;
                        return;
                    }
                    slope = (0.f - amplitude) / (float)half;
                    nextBoundary = half;
                }
                else
                {
                    finished = true;
                }
            }
        }
    };

    //---------------------------------------------------------------
    // ASR envelope state
    //---------------------------------------------------------------
    struct ASREnvelopeState
    {
        float amplitude = 0.0f;
        float slope = 0.0f;
        bool  finished = false;
        bool  isPunchy = false;
        int   segmentIndex = 0;

        int   totalSamples = 0;
        int   samplesDone = 0;
        int   nextBoundary = 0;

        float grainAmp = 0.0f; // final amplitude
        float attackRatio = 3.f;
        float sustainRatio = 10.f;
        float releaseRatio = 11.f;

        void initNormal(float gA, int durSamples)
        {
            finished = false;
            isPunchy = false;
            segmentIndex = 0;
            totalSamples = durSamples;
            samplesDone = 0;
            grainAmp = gA;

            if (durSamples < 2)
            {
                amplitude = 0.f;
                slope = 0.f;
                finished = true;
                return;
            }

            int attackSamples = (int)std::round((float)durSamples * attackRatio / (attackRatio + sustainRatio + releaseRatio));
            if (attackSamples < 1)
                attackSamples = 1;
            amplitude = 0.f;
            slope = gA / (float)attackSamples;
            nextBoundary = attackSamples;
        }

        void initPunchy(float gA, int durSamples)
        {
            finished = false;
            isPunchy = true;
            segmentIndex = 0;
            totalSamples = durSamples;
            samplesDone = 0;
            grainAmp = gA;

            if (durSamples < 2)
            {
                amplitude = 0.f;
                slope = 0.f;
                finished = true;
                return;
            }

            int attackSamples = (int)std::round((float)durSamples * attackRatio / (attackRatio + releaseRatio));
            if (attackSamples < 1)
                attackSamples = 1;
            amplitude = gA;
            slope = 0.f;
            nextBoundary = attackSamples;
        }

        inline void advanceSegment()
        {
            if (!isPunchy)
            {
                if (segmentIndex == 0) // Attack -> Sustain
                {
                    segmentIndex = 1;
                    int sustainSamples = (int)std::round((float)totalSamples * sustainRatio / (attackRatio + sustainRatio + releaseRatio));
                    if (sustainSamples < 1)
                    {
                        finished = true;
                        return;
                    }
                    amplitude = grainAmp;
                    slope = 0.0f;
                    nextBoundary = sustainSamples;
                }
                else if (segmentIndex == 1) // Sustain -> Release
                {
                    segmentIndex = 2;
                    int releaseSamples = totalSamples - (int)std::round((float)totalSamples * (attackRatio + sustainRatio) / (attackRatio + sustainRatio + releaseRatio));
                    if (releaseSamples < 1)
                    {
                        finished = true;
                        return;
                    }
                    amplitude = grainAmp;
                    slope = (0.f - grainAmp) / (float)releaseSamples;
                    nextBoundary = releaseSamples;
                }
                else
                {
                    finished = true;
                }
            }
            else
            {
                if (segmentIndex == 0) // Attack -> Release
                {
                    segmentIndex = 1;
                    int releaseSamples = totalSamples - (int)std::round((float)totalSamples * attackRatio / (attackRatio + releaseRatio));
                    if (releaseSamples < 1)
                    {
                        finished = true;
                        return;
                    }
                    amplitude = grainAmp;
                    slope = (0.f - amplitude) / (float)releaseSamples;
                    nextBoundary = releaseSamples;
                }
                else
                {
                    finished = true;
                }
            }
        }
    };

    //==============================================================================
    // Forward Declarations for Envelope Rendering Functions
    //==============================================================================
    static int vectorSynthesizeParabolic(struct Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength);

    static int vectorSynthesizePunchyParabolic(struct Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength);

    static int vectorSynthesizeTriangle(struct Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength);

    static int vectorSynthesizePunchyTriangle(struct Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength);

    static int vectorSynthesizeASR(struct Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength);

    static int vectorSynthesizePunchyASR(struct Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength);

    //==============================================================================
    // Grain struct
    //==============================================================================
    struct Grain
    {
        const float* sourceL = nullptr;
        const float* sourceR = nullptr;

        double position = 0.0;    // samples processed so far
        double duration = 0.0;    // total length in samples
        double delta = 0.0;       // pitch read increment
        double sourceReadLength = 0.0;
        bool   active = false;

        float  grainAmplitude = 1.0f;
        GrainEssence essence;
        EnvelopeMode envelopeMode = EnvelopeMode::Parabolic;

        // Function pointer for envelope rendering.
        using EnvelopeFunction = int(*)(Grain&, float*, float*, int, int);
        EnvelopeFunction envelopeRenderFn = nullptr;

        // Envelope state instances.
        ParabolicEnvelopeState  parabState;
        LinearEnvelopeState     linearState;
        ASREnvelopeState        asrState;

        void activateEnvelope(EnvelopeFunction fn,
            double dur,
            double d,
            const std::array<const float*, 2>& src,
            float amp,
            const GrainEssence& e,
            int bufferLength)
        {
            duration = dur;
            delta = d;

            double centsFact = std::pow(2.0, e.pitchOffsetCents / 1200.0);
            sourceReadLength = (d * centsFact) * dur;

            duration *= e.sizeMult;
            sourceReadLength *= e.sizeMult;

            position = 0.0;
            sourceL = src[0];
            sourceR = src[1];
            grainAmplitude = amp * e.volumeMult;
            active = true;
            essence = e;

            envelopeRenderFn = fn;

            int durSamples = (int)std::lround(duration);
            if (durSamples < 1)
                durSamples = 1;

            if (fn == &vectorSynthesizeParabolic)
                parabState.initNormal(grainAmplitude, durSamples);
            else if (fn == &vectorSynthesizePunchyParabolic)
                parabState.initPunchy(grainAmplitude, durSamples);
            else if (fn == &vectorSynthesizeTriangle)
                linearState.initNormal(grainAmplitude, durSamples);
            else if (fn == &vectorSynthesizePunchyTriangle)
                linearState.initPunchy(grainAmplitude, durSamples);
            else if (fn == &vectorSynthesizeASR)
                asrState.initNormal(grainAmplitude, durSamples);
            else // punchy ASR
                asrState.initPunchy(grainAmplitude, durSamples);
        }

        int vectorSynthesize(float* outL, float* outR, int blockSize, int bufferLength)
        {
            if (!active)
                return 0;
            return envelopeRenderFn(*this, outL, outR, blockSize, bufferLength);
        }

        bool isActive() const { return active; }
    };

    //==============================================================================
    // Envelope Rendering Functions
    //==============================================================================

    // 1) Normal Parabolic
    static int vectorSynthesizeParabolic(Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength)
    {
        auto& st = grain.parabState;
        if (st.finished || !grain.active)
        {
            grain.active = false;
            return 0;
        }
        int processed = 0;
        int remain = blockSize;

        const float srl = (float)grain.sourceReadLength;
        const float startOff = grain.essence.startOffsetInSamples;
        const float pan = grain.essence.panning;
        const float leftGain = 0.5f * (1.0f - pan);
        const float rightGain = 0.5f * (1.0f + pan);
        const float* srcL = grain.sourceL;
        const float* srcR = grain.sourceR;
        const float invTotal = (st.totalSamples > 0 ? 1.0f / st.totalSamples : 0.f);

        float amp = st.amplitude;
        float slope = st.slope;
        float curve = st.curve;
        int samplesDone = st.samplesDone;
        int totalSamples = st.totalSamples;
        int localBoundary = st.nextBoundary;
        bool finished = st.finished;

        while (remain > 0 && !finished)
        {
            int boundary = (remain < localBoundary ? remain : localBoundary);
            for (int i = 0; i < boundary; ++i)
            {
                float env = amp;
                amp += slope;
                slope += curve;
                float x = (totalSamples > 1 ? samplesDone * invTotal : 0.f);
                float effPos = x * srl + startOff;
                float sampleL = 0.f, sampleR = 0.f;
                int idx0 = (int)effPos;
                if (effPos >= 0.f && idx0 < bufferLength)
                {
                    int idx1 = (idx0 + 1 < bufferLength ? idx0 + 1 : bufferLength - 1);
                    float frac = effPos - (float)idx0;
                    sampleL = srcL[idx0] + frac * (srcL[idx1] - srcL[idx0]);
                    sampleR = srcR[idx0] + frac * (srcR[idx1] - srcR[idx0]);
                }
                sampleL *= (env * leftGain);
                sampleR *= (env * rightGain);
                outL[processed + i] += sampleL;
                outR[processed + i] += sampleR;
                ++samplesDone;
                if (samplesDone >= totalSamples)
                {
                    finished = true;
                    break;
                }
            }
            remain -= boundary;
            processed += boundary;
            localBoundary -= boundary;
            if (localBoundary <= 0 && !finished)
            {
                st.amplitude = amp;
                st.slope = slope;
                st.curve = curve;
                st.samplesDone = samplesDone;
                st.nextBoundary = localBoundary;
                st.advanceSegment();
                amp = st.amplitude;
                slope = st.slope;
                curve = st.curve;
                samplesDone = st.samplesDone;
                totalSamples = st.totalSamples;
                localBoundary = st.nextBoundary;
                finished = st.finished;
            }
        }
        st.amplitude = amp;
        st.slope = slope;
        st.curve = curve;
        st.samplesDone = samplesDone;
        st.nextBoundary = localBoundary;
        st.finished = finished;
        if (finished)
            grain.active = false;
        return processed;
    }

    // 2) Punchy Parabolic
    static int vectorSynthesizePunchyParabolic(Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength)
    {
        auto& st = grain.parabState;
        if (st.finished || !grain.active)
        {
            grain.active = false;
            return 0;
        }
        int processed = 0;
        int remain = blockSize;

        const float srl = (float)grain.sourceReadLength;
        const float startOff = grain.essence.startOffsetInSamples;
        const float pan = grain.essence.panning;
        const float leftGain = 0.5f * (1.0f - pan);
        const float rightGain = 0.5f * (1.0f + pan);
        const float* srcL = grain.sourceL;
        const float* srcR = grain.sourceR;
        const float invTotal = (st.totalSamples > 0 ? 1.0f / st.totalSamples : 0.f);

        float amp = st.amplitude;
        float slope = st.slope;
        float curve = st.curve;
        int samplesDone = st.samplesDone;
        int totalSamples = st.totalSamples;
        int localBoundary = st.nextBoundary;
        bool finished = st.finished;
        int segIndex = st.segmentIndex;

        while (remain > 0 && !finished)
        {
            int boundary = (remain < localBoundary ? remain : localBoundary);
            for (int i = 0; i < boundary; ++i)
            {
                float env = amp;
                if (segIndex == 1)
                {
                    amp += slope;
                    slope += curve;
                    env = amp;
                }
                float x = (totalSamples > 1 ? samplesDone * invTotal : 0.f);
                float effPos = x * srl + startOff;
                float sampleL = 0.f, sampleR = 0.f;
                int idx0 = (int)effPos;
                if (effPos >= 0.f && idx0 < bufferLength)
                {
                    int idx1 = (idx0 + 1 < bufferLength ? idx0 + 1 : bufferLength - 1);
                    float frac = effPos - (float)idx0;
                    sampleL = srcL[idx0] + frac * (srcL[idx1] - srcL[idx0]);
                    sampleR = srcR[idx0] + frac * (srcR[idx1] - srcR[idx0]);
                }
                if (segIndex == 0)
                    env = st.finalAmplitude;
                sampleL *= (env * leftGain);
                sampleR *= (env * rightGain);
                outL[processed + i] += sampleL;
                outR[processed + i] += sampleR;
                ++samplesDone;
                if (samplesDone >= totalSamples)
                {
                    finished = true;
                    break;
                }
            }
            remain -= boundary;
            processed += boundary;
            localBoundary -= boundary;
            if (localBoundary <= 0 && !finished)
            {
                st.amplitude = amp;
                st.slope = slope;
                st.curve = curve;
                st.samplesDone = samplesDone;
                st.nextBoundary = localBoundary;
                st.advanceSegment();
                segIndex = st.segmentIndex;
                amp = st.amplitude;
                slope = st.slope;
                curve = st.curve;
                samplesDone = st.samplesDone;
                totalSamples = st.totalSamples;
                localBoundary = st.nextBoundary;
                finished = st.finished;
            }
        }
        st.amplitude = amp;
        st.slope = slope;
        st.curve = curve;
        st.samplesDone = samplesDone;
        st.nextBoundary = localBoundary;
        st.finished = finished;
        if (finished)
            grain.active = false;
        return processed;
    }

    // 3) Normal Triangle
    static int vectorSynthesizeTriangle(Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength)
    {
        auto& st = grain.linearState;
        if (st.finished || !grain.active)
        {
            grain.active = false;
            return 0;
        }
        int processed = 0;
        int remain = blockSize;

        const float srl = (float)grain.sourceReadLength;
        const float startOff = grain.essence.startOffsetInSamples;
        const float pan = grain.essence.panning;
        const float leftGain = 0.5f * (1.0f - pan);
        const float rightGain = 0.5f * (1.0f + pan);
        const float* srcL = grain.sourceL;
        const float* srcR = grain.sourceR;
        const float invTotal = (st.totalSamples > 0 ? 1.0f / st.totalSamples : 0.f);

        float amp = st.amplitude;
        float slope = st.slope;
        int samplesDone = st.samplesDone;
        int totalSamples = st.totalSamples;
        int localBoundary = st.nextBoundary;
        bool finished = st.finished;

        while (remain > 0 && !finished)
        {
            int boundary = (remain < localBoundary ? remain : localBoundary);
            for (int i = 0; i < boundary; ++i)
            {
                float env = amp;
                amp += slope;
                float x = (totalSamples > 1 ? samplesDone * invTotal : 0.f);
                float effPos = x * srl + startOff;
                float sampleL = 0.f, sampleR = 0.f;
                int idx0 = (int)effPos;
                if (effPos >= 0.f && idx0 < bufferLength)
                {
                    int idx1 = (idx0 + 1 < bufferLength ? idx0 + 1 : bufferLength - 1);
                    float frac = effPos - (float)idx0;
                    sampleL = srcL[idx0] + frac * (srcL[idx1] - srcL[idx0]);
                    sampleR = srcR[idx0] + frac * (srcR[idx1] - srcR[idx0]);
                }
                sampleL *= (env * leftGain);
                sampleR *= (env * rightGain);
                outL[processed + i] += sampleL;
                outR[processed + i] += sampleR;
                ++samplesDone;
                if (samplesDone >= totalSamples)
                {
                    finished = true;
                    break;
                }
            }
            remain -= boundary;
            processed += boundary;
            localBoundary -= boundary;
            if (localBoundary <= 0 && !finished)
            {
                st.amplitude = amp;
                st.slope = slope;
                st.samplesDone = samplesDone;
                st.nextBoundary = localBoundary;
                st.advanceSegment();
                amp = st.amplitude;
                slope = st.slope;
                samplesDone = st.samplesDone;
                totalSamples = st.totalSamples;
                localBoundary = st.nextBoundary;
                finished = st.finished;
            }
        }
        st.amplitude = amp;
        st.slope = slope;
        st.samplesDone = samplesDone;
        st.nextBoundary = localBoundary;
        st.finished = finished;
        if (finished)
            grain.active = false;
        return processed;
    }

    // 4) Punchy Triangle
    static int vectorSynthesizePunchyTriangle(Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength)
    {
        auto& st = grain.linearState;
        if (st.finished || !grain.active)
        {
            grain.active = false;
            return 0;
        }
        int processed = 0;
        int remain = blockSize;

        const float srl = (float)grain.sourceReadLength;
        const float startOff = grain.essence.startOffsetInSamples;
        const float pan = grain.essence.panning;
        const float leftGain = 0.5f * (1.0f - pan);
        const float rightGain = 0.5f * (1.0f + pan);
        const float* srcL = grain.sourceL;
        const float* srcR = grain.sourceR;
        const float invTotal = (st.totalSamples > 0 ? 1.0f / st.totalSamples : 0.f);

        float amp = st.amplitude;
        float slope = st.slope;
        int samplesDone = st.samplesDone;
        int totalSamples = st.totalSamples;
        int localBoundary = st.nextBoundary;
        bool finished = st.finished;

        while (remain > 0 && !finished)
        {
            int boundary = (remain < localBoundary ? remain : localBoundary);
            for (int i = 0; i < boundary; ++i)
            {
                float env = amp;
                if (st.segmentIndex == 1)
                    amp += slope;
                float x = (totalSamples > 1 ? samplesDone * invTotal : 0.f);
                float effPos = x * srl + startOff;
                float sampleL = 0.f, sampleR = 0.f;
                int idx0 = (int)effPos;
                if (effPos >= 0.f && idx0 < bufferLength)
                {
                    int idx1 = (idx0 + 1 < bufferLength ? idx0 + 1 : bufferLength - 1);
                    float frac = effPos - (float)idx0;
                    sampleL = srcL[idx0] + frac * (srcL[idx1] - srcL[idx0]);
                    sampleR = srcR[idx0] + frac * (srcR[idx1] - srcR[idx0]);
                }
                sampleL *= (env * leftGain);
                sampleR *= (env * rightGain);
                outL[processed + i] += sampleL;
                outR[processed + i] += sampleR;
                ++samplesDone;
                if (samplesDone >= totalSamples)
                {
                    finished = true;
                    break;
                }
            }
            remain -= boundary;
            processed += boundary;
            localBoundary -= boundary;
            if (localBoundary <= 0 && !finished)
            {
                st.amplitude = amp;
                st.slope = slope;
                st.samplesDone = samplesDone;
                st.nextBoundary = localBoundary;
                st.advanceSegment();
                amp = st.amplitude;
                slope = st.slope;
                samplesDone = st.samplesDone;
                totalSamples = st.totalSamples;
                localBoundary = st.nextBoundary;
                finished = st.finished;
            }
        }
        st.amplitude = amp;
        st.slope = slope;
        st.samplesDone = samplesDone;
        st.nextBoundary = localBoundary;
        st.finished = finished;
        if (finished)
            grain.active = false;
        return processed;
    }

    // 5) Normal ASR
    static int vectorSynthesizeASR(Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength)
    {
        auto& st = grain.asrState;
        if (st.finished || !grain.active)
        {
            grain.active = false;
            return 0;
        }
        int processed = 0;
        int remain = blockSize;

        const float srl = (float)grain.sourceReadLength;
        const float startOff = grain.essence.startOffsetInSamples;
        const float pan = grain.essence.panning;
        const float leftGain = 0.5f * (1.0f - pan);
        const float rightGain = 0.5f * (1.0f + pan);
        const float* srcL = grain.sourceL;
        const float* srcR = grain.sourceR;
        const float invTotal = (st.totalSamples > 0 ? 1.0f / st.totalSamples : 0.f);

        float amp = st.amplitude;
        float slope = st.slope;
        int samplesDone = st.samplesDone;
        int totalSamples = st.totalSamples;
        int localBoundary = st.nextBoundary;
        bool finished = st.finished;

        while (remain > 0 && !finished)
        {
            int boundary = (remain < localBoundary ? remain : localBoundary);
            for (int i = 0; i < boundary; ++i)
            {
                float env = amp;
                amp += slope;
                float x = (totalSamples > 1 ? samplesDone * invTotal : 0.f);
                float effPos = x * srl + startOff;
                float sampleL = 0.f, sampleR = 0.f;
                int idx0 = (int)effPos;
                if (effPos >= 0.f && idx0 < bufferLength)
                {
                    int idx1 = (idx0 + 1 < bufferLength ? idx0 + 1 : bufferLength - 1);
                    float frac = effPos - (float)idx0;
                    sampleL = srcL[idx0] + frac * (srcL[idx1] - srcL[idx0]);
                    sampleR = srcR[idx0] + frac * (srcR[idx1] - srcR[idx0]);
                }
                sampleL *= (env * leftGain);
                sampleR *= (env * rightGain);
                outL[processed + i] += sampleL;
                outR[processed + i] += sampleR;
                ++samplesDone;
                if (samplesDone >= totalSamples)
                {
                    finished = true;
                    break;
                }
            }
            remain -= boundary;
            processed += boundary;
            localBoundary -= boundary;
            if (localBoundary <= 0 && !finished)
            {
                st.amplitude = amp;
                st.slope = slope;
                st.samplesDone = samplesDone;
                st.nextBoundary = localBoundary;
                st.advanceSegment();
                amp = st.amplitude;
                slope = st.slope;
                samplesDone = st.samplesDone;
                totalSamples = st.totalSamples;
                localBoundary = st.nextBoundary;
                finished = st.finished;
            }
        }
        st.amplitude = amp;
        st.slope = slope;
        st.samplesDone = samplesDone;
        st.nextBoundary = localBoundary;
        st.finished = finished;
        if (finished)
            grain.active = false;
        return processed;
    }

    // 6) Punchy ASR
    static int vectorSynthesizePunchyASR(Grain& grain,
        float* outL, float* outR,
        int blockSize, int bufferLength)
    {
        auto& st = grain.asrState;
        if (st.finished || !grain.active)
        {
            grain.active = false;
            return 0;
        }
        int processed = 0;
        int remain = blockSize;

        const float srl = (float)grain.sourceReadLength;
        const float startOff = grain.essence.startOffsetInSamples;
        const float pan = grain.essence.panning;
        const float leftGain = 0.5f * (1.0f - pan);
        const float rightGain = 0.5f * (1.0f + pan);
        const float* srcL = grain.sourceL;
        const float* srcR = grain.sourceR;
        const float invTotal = (st.totalSamples > 0 ? 1.0f / st.totalSamples : 0.f);

        float amp = st.amplitude;
        float slope = st.slope;
        int samplesDone = st.samplesDone;
        int totalSamples = st.totalSamples;
        int localBoundary = st.nextBoundary;
        bool finished = st.finished;

        while (remain > 0 && !finished)
        {
            int boundary = (remain < localBoundary ? remain : localBoundary);
            for (int i = 0; i < boundary; ++i)
            {
                float env = amp;
                if (st.segmentIndex == 1)
                    amp += slope;
                float x = (totalSamples > 1 ? samplesDone * invTotal : 0.f);
                float effPos = x * srl + startOff;
                float sampleL = 0.f, sampleR = 0.f;
                int idx0 = (int)effPos;
                if (effPos >= 0.f && idx0 < bufferLength)
                {
                    int idx1 = (idx0 + 1 < bufferLength ? idx0 + 1 : bufferLength - 1);
                    float frac = effPos - (float)idx0;
                    sampleL = srcL[idx0] + frac * (srcL[idx1] - srcL[idx0]);
                    sampleR = srcR[idx0] + frac * (srcR[idx1] - srcR[idx0]);
                }
                sampleL *= (env * leftGain);
                sampleR *= (env * rightGain);
                outL[processed + i] += sampleL;
                outR[processed + i] += sampleR;
                ++samplesDone;
                if (samplesDone >= totalSamples)
                {
                    finished = true;
                    break;
                }
            }
            remain -= boundary;
            processed += boundary;
            localBoundary -= boundary;
            if (localBoundary <= 0 && !finished)
            {
                st.amplitude = amp;
                st.slope = slope;
                st.samplesDone = samplesDone;
                st.nextBoundary = localBoundary;
                st.advanceSegment();
                amp = st.amplitude;
                slope = st.slope;
                samplesDone = st.samplesDone;
                totalSamples = st.totalSamples;
                localBoundary = st.nextBoundary;
                finished = st.finished;
            }
        }
        st.amplitude = amp;
        st.slope = slope;
        st.samplesDone = samplesDone;
        st.nextBoundary = localBoundary;
        st.finished = finished;
        if (finished)
            grain.active = false;
        return processed;
    }

    //==============================================================================
    // Scheduling Functions
    //==============================================================================
    struct Granular_Synth_2_Helper
    {
        static void scheduleGrainNormal(
            bool& /*unusedFirstGrainFlag*/,
            std::array<Grain, 1>& /*punchyGrainPool*/,
            std::array<Grain, 11>& normalGrainPool,
            double grainDuration,
            double baseDelta,
            const std::array<const float*, 2>& sample,
            float grainAmp,
            const GrainEssence& essence,
            int bufferLen,
            int /*unusedAtt*/,
            int /*unusedRel*/,
            Grain::EnvelopeFunction normalEnvelopeFn,
            Grain::EnvelopeFunction /*punchyEnvelopeFn*/)
        {
            for (auto& g : normalGrainPool)
            {
                if (!g.isActive())
                {
                    g.activateEnvelope(normalEnvelopeFn,
                        grainDuration,
                        baseDelta,
                        sample,
                        grainAmp,
                        essence,
                        bufferLen);
                    break;
                }
            }
        }

        static void scheduleGrainPunchy(
            bool& firstGrainScheduled,
            std::array<Grain, 1>& punchyGrainPool,
            std::array<Grain, 11>& normalGrainPool,
            double grainDuration,
            double baseDelta,
            const std::array<const float*, 2>& sample,
            float grainAmp,
            const GrainEssence& essence,
            int bufferLen,
            int /*unusedAtt*/,
            int /*unusedRel*/,
            Grain::EnvelopeFunction normalEnvelopeFn,
            Grain::EnvelopeFunction punchyEnvelopeFn)
        {
            if (!firstGrainScheduled)
            {
                for (auto& g : punchyGrainPool)
                {
                    if (!g.isActive())
                    {
                        g.activateEnvelope(punchyEnvelopeFn,
                            grainDuration,
                            baseDelta,
                            sample,
                            grainAmp,
                            essence,
                            bufferLen);
                        firstGrainScheduled = true;
                        break;
                    }
                }
            }
            else
            {
                for (auto& g : normalGrainPool)
                {
                    if (!g.isActive())
                    {
                        g.activateEnvelope(normalEnvelopeFn,
                            grainDuration,
                            baseDelta,
                            sample,
                            grainAmp,
                            essence,
                            bufferLen);
                        break;
                    }
                }
            }
        }
    };

    using ScheduleGrainFunction = void(*)(bool&,
        std::array<Grain, 1>&,
        std::array<Grain, 11>&,
        double, double,
        const std::array<const float*, 2>&,
        float,
        const GrainEssence&,
        int,
        int,
        int,
        Grain::EnvelopeFunction,
        Grain::EnvelopeFunction);

    //==============================================================================
    // Granular_Synth_2 Class Template
    //==============================================================================
    template <int NV>
    struct Granular_Synth : public data::base
    {
        SNEX_NODE(Granular_Synth);
        struct MetadataClass { SN_NODE_ID("Granular_Synth"); };

        static constexpr bool isModNode() { return false; }
        static constexpr bool isPolyphonic() { return NV > 1; }
        static constexpr bool hasTail() { return true; }
        static constexpr bool isSuspendedOnSilence() { return false; }
        static constexpr int  getFixChannelAmount() { return 2; }

        static constexpr int NumTables = 0;
        static constexpr int NumSliderPacks = 0;
        static constexpr int NumAudioFiles = 1;
        static constexpr int NumFilters = 0;
        static constexpr int NumDisplayBuffers = 0;

        struct Voice
        {
            int   midiNote = 60;
            bool  isActive = false;
            float velocity = 1.0f;

            std::array<Grain, 1> punchyGrainPool;
            std::array<Grain, 11> normalGrainPool;

            int    grainSchedulerCounter = 0;
            double grainSchedulerInterval = 0.0;
            double modPhase = 0.0;

            bool firstGrainScheduled = false;
            double scanDirection = 1.0;

            void reset(int note, float vel, int /*grainSizeSamples*/, int grainIntervalSamples)
            {
                midiNote = note;
                velocity = vel;
                isActive = true;
                firstGrainScheduled = false;
                for (auto& gr : punchyGrainPool)
                    gr.active = false;
                for (auto& gr : normalGrainPool)
                    gr.active = false;
                grainSchedulerCounter = 0;
                grainSchedulerInterval = (double)grainIntervalSamples;
                modPhase = 0.0;
                scanDirection = 1.0;
            }
        };

        PolyData<Voice, NV> voices;
        ExternalData sampleData;
        AudioBuffer<float> sampleBuffer;
        std::array<const float*, 2> sample{ nullptr, nullptr };

        std::array<float, 128> pitchRatios{};
        double sampleRate = 44100.0;
        // Now sampleRateRatio is computed from the file sample rate (stored in sampleData.sampleRate)
        double sampleRateRatio = 1.0;
        int    grainSizeInSamples = 0;
        int    grainIntervalInSamples = 0;
        double globalPitchOffsetFactor = 1.0;

        float  grainStartPercent = 0.0f;
        float  grainStartOffsetInSamples = 0.0f;
        double grainPitchOffsetSemitones = 0.0;
        ModValue gate;

        std::mt19937 randomGen;

        double grainOffsetCentsRange = 10.0;
        float  grainVolumeMin = 0.8f;
        float  grainPanRange = 0.25f;
        double grainGapAdjustmentMaxSec = 0.25;
        float  grainSizeRandom = 0.0f;
        double grainSizeMS = 1000.0;
        double grainIntervalMS = 1500.0;
        float  grainSpray = 0.0f;
        float  grainSprayMode = 0.0f;
        bool   startModEnabled = false;
        double startModTimeSec = 0.0;

        int raisedCosAttackSamples = 0;
        int raisedCosReleaseSamples = 0;

        bool punchyMode = false;
        int envelopeType = 0;

        typename Grain::EnvelopeFunction normalEnvelopeFn = &vectorSynthesizeParabolic;
        typename Grain::EnvelopeFunction punchyEnvelopeFn = &vectorSynthesizePunchyParabolic;
        ScheduleGrainFunction scheduleGrainFn = nullptr;

        std::vector<float> tempBlockOutL;
        std::vector<float> tempBlockOutR;

        // Optimized reflection function.
        // This function assumes that in the common case, the offset is within one double-length (2*bufferLen).
        // If not, we fall back to std::fmod.
        inline static float reflectOffset(float offset, float bufferLen)
        {
            const float doubleLen = 2.0f * bufferLen;

            // Fast-path: if offset is already in the range [-doubleLen, doubleLen]
            if (offset > -doubleLen && offset < doubleLen)
            {
                // Make sure offset is non-negative.
                if (offset < 0.0f)
                    offset += doubleLen;
            }
            else
            {
                // Fall back to modulo for out-of-range values.
                offset = std::fmod(offset, doubleLen);
                if (offset < 0.0f)
                    offset += doubleLen;
            }

            // Reflect if offset exceeds bufferLen.
            // (For values between bufferLen and doubleLen, we map them back down.)
            if (offset > bufferLen)
                offset = doubleLen - offset;

            return offset;
        }

        void prepare(PrepareSpecs specs)
        {
            sampleRate = specs.sampleRate;
            initPitchRatios();
            updateDerivedParameters();
            voices.prepare(specs);

            std::random_device rd;
            randomGen.seed(rd());

            if (punchyMode)
                scheduleGrainFn = &Granular_Synth_2_Helper::scheduleGrainPunchy;
            else
                scheduleGrainFn = &Granular_Synth_2_Helper::scheduleGrainNormal;
            updateEnvelopeFunctions();
        }

        void updateDerivedParameters()
        {
            grainSizeInSamples = (int)std::lround((grainSizeMS / 1000.0) * sampleRate);
            grainIntervalInSamples = (int)std::lround((grainIntervalMS / 1000.0) * sampleRate);
            // Use the sample's file sample rate from ExternalData (if available) instead of 44100
            sampleRateRatio = (sampleData.sampleRate > 0 ? sampleData.sampleRate : 44100.0) / sampleRate;
            globalPitchOffsetFactor = std::pow(2.0, grainPitchOffsetSemitones / 12.0);
            int currentSampleLength = sampleBuffer.getNumSamples();
            if (currentSampleLength < 1)
                currentSampleLength = 1;
            grainStartOffsetInSamples = grainStartPercent * (float)(currentSampleLength - 1);
            raisedCosAttackSamples = (int)std::lround(0.02 * sampleRate);
            raisedCosReleaseSamples = (int)std::lround(0.02 * sampleRate);
        }

        void updateEnvelopeFunctions()
        {
            if (envelopeType == 0)
            {
                normalEnvelopeFn = &vectorSynthesizeParabolic;
                punchyEnvelopeFn = &vectorSynthesizePunchyParabolic;
            }
            else if (envelopeType == 1)
            {
                normalEnvelopeFn = &vectorSynthesizeTriangle;
                punchyEnvelopeFn = &vectorSynthesizePunchyTriangle;
            }
            else // ASR
            {
                normalEnvelopeFn = &vectorSynthesizeASR;
                punchyEnvelopeFn = &vectorSynthesizePunchyASR;
            }
        }

        void reset()
        {
            for (auto& voice : voices)
                voice.isActive = false;
        }

        void setExternalData(const ExternalData& ed, int /*index*/)
        {
            sampleData = ed;
            AudioSampleBuffer tempBuffer = ed.toAudioSampleBuffer();
            int numSamples = tempBuffer.getNumSamples();
            int numChannels = tempBuffer.getNumChannels();

            if (numSamples <= 0)
            {
                static AudioBuffer<float> safetyBuffer(2, 4);
                safetyBuffer.clear();
                sampleBuffer.makeCopyOf(safetyBuffer, true);
            }
            else
            {
                sampleBuffer.makeCopyOf(tempBuffer, true);
            }

            sample[0] = sampleBuffer.getReadPointer(0);
            if (numChannels > 1)
                sample[1] = sampleBuffer.getReadPointer(1);
            else
                sample[1] = sample[0];

            updateDerivedParameters();
        }

        void handleHiseEvent(HiseEvent& e)
        {
            if (e.isNoteOn())
            {
                auto& voice = voices.get();
                voice.reset(e.getNoteNumber(),
                    e.getFloatVelocity(),
                    grainSizeInSamples,
                    grainIntervalInSamples);
            }
        }

        // Process function with interleaved grain activation and synthesis.
        template <typename ProcessDataType>
        void process(ProcessDataType& data)
        {
            DataReadLock sl(this->sampleData);
            auto& fixData = data.template as<ProcessData<getFixChannelAmount()>>();
            auto audioBlock = fixData.toAudioBlock();
            auto* leftChannel = audioBlock.getChannelPointer(0);
            auto* rightChannel = audioBlock.getChannelPointer(1);
            int totalSamples = data.getNumSamples();

            if (sampleBuffer.getNumSamples() == 0)
            {
                audioBlock.clear();
                return;
            }

            std::fill(leftChannel, leftChannel + totalSamples, 0.0f);
            std::fill(rightChannel, rightChannel + totalSamples, 0.0f);

            if (tempBlockOutL.size() < (size_t)totalSamples)
            {
                tempBlockOutL.resize(totalSamples, 0.f);
                tempBlockOutR.resize(totalSamples, 0.f);
            }

            const int sampleLen = sampleBuffer.getNumSamples();
            int globalOffset = 0;

            // Main processing loop: process a segment of the output until we complete the block.
            while (globalOffset < totalSamples)
            {
                // Determine the next event time (in samples) across all voices.
                int nextEvent = totalSamples - globalOffset;
                for (auto& voice : voices)
                {
                    if (!voice.isActive)
                        continue;
                    nextEvent = std::min(nextEvent, voice.grainSchedulerCounter);
                    for (auto& grain : voice.normalGrainPool)
                    {
                        if (grain.isActive())
                        {
                            int rem = (int)(grain.duration - grain.position);
                            nextEvent = std::min(nextEvent, rem);
                        }
                    }
                    for (auto& grain : voice.punchyGrainPool)
                    {
                        if (grain.isActive())
                        {
                            int rem = (int)(grain.duration - grain.position);
                            nextEvent = std::min(nextEvent, rem);
                        }
                    }
                }
                if (nextEvent < 1)
                    nextEvent = 1;

                // Clear temporary buffers for the current segment.
                std::fill(tempBlockOutL.begin(), tempBlockOutL.begin() + nextEvent, 0.f);
                std::fill(tempBlockOutR.begin(), tempBlockOutR.begin() + nextEvent, 0.f);

                // Synthesize active grains for the current segment.
                for (auto& voice : voices)
                {
                    if (!voice.isActive)
                        continue;
                    for (auto& grain : voice.punchyGrainPool)
                    {
                        if (grain.isActive())
                        {
                            int n = grain.vectorSynthesize(tempBlockOutL.data(), tempBlockOutR.data(), nextEvent, sampleLen);
                            grain.position += n;
                        }
                    }
                    for (auto& grain : voice.normalGrainPool)
                    {
                        if (grain.isActive())
                        {
                            int n = grain.vectorSynthesize(tempBlockOutL.data(), tempBlockOutR.data(), nextEvent, sampleLen);
                            grain.position += n;
                        }
                    }
                }

                // Mix the synthesized segment into the output channels.
                for (int i = 0; i < nextEvent; ++i)
                {
                    leftChannel[globalOffset + i] += tempBlockOutL[i];
                    rightChannel[globalOffset + i] += tempBlockOutR[i];
                }

                // Interleaved grain scheduling: update each voice's scheduler counter and activate new grains if due.
                for (auto& voice : voices)
                {
                    if (!voice.isActive)
                        continue;
                    voice.grainSchedulerCounter -= nextEvent;
                    // If the scheduler counter has expired, schedule new grains immediately.
                    while (voice.grainSchedulerCounter <= 0)
                    {
                        double baseDelta = pitchRatios[voice.midiNote] * sampleRateRatio * globalPitchOffsetFactor;
                        double grainDuration = (double)grainSizeInSamples;
                        GrainEssence essence;
                        {
                            std::uniform_real_distribution<double> pitchOffDist(-grainOffsetCentsRange, grainOffsetCentsRange);
                            essence.pitchOffsetCents = pitchOffDist(randomGen);
                            std::uniform_real_distribution<float> volDist(grainVolumeMin, 1.0f);
                            essence.volumeMult = volDist(randomGen);
                            std::uniform_real_distribution<float> panDist(-grainPanRange, grainPanRange);
                            essence.panning = panDist(randomGen);
                            std::uniform_int_distribution<int> gapDist(0, (int)std::lround(grainGapAdjustmentMaxSec * sampleRate));
                            essence.gapAdjustment = gapDist(randomGen);
                            std::uniform_real_distribution<float> sizeDist(1.0f - grainSizeRandom, 1.0f);
                            essence.sizeMult = sizeDist(randomGen);
                            float finalStartOffset = grainStartOffsetInSamples;
                            if (startModEnabled && startModTimeSec > 0.00001)
                            {
                                int samplesPassed = grainIntervalInSamples + essence.gapAdjustment;
                                double timeSec = (double)samplesPassed / sampleRate;
                                double cycleTime = startModTimeSec;
                                double increment = timeSec / cycleTime;
                                voice.modPhase += increment * voice.scanDirection;
                                if (voice.modPhase >= 1.0)
                                {
                                    voice.modPhase = 2.0 - voice.modPhase;
                                    voice.scanDirection = -1.0;
                                }
                                else if (voice.modPhase <= 0.0)
                                {
                                    voice.modPhase = -voice.modPhase;
                                    voice.scanDirection = 1.0;
                                }
                                float curPercent = (float)voice.modPhase;
                                finalStartOffset = curPercent * (float)(sampleLen - 1);
                            }
                            if (grainSpray > 0.0f)
                            {
                                std::uniform_real_distribution<float> sprayDist(0.0f, 1.0f);
                                float rnd = sprayDist(randomGen);
                                float left = -grainSprayMode * grainSpray * (float)sampleLen;
                                float range = grainSpray * (1.0f + grainSprayMode) * (float)sampleLen;
                                float offset = left + rnd * range;
                                finalStartOffset += offset;
                            }
                            if (grainSprayMode >= 0.5f)
                            {
                                finalStartOffset = reflectOffset(finalStartOffset, (float)sampleLen);
                            }
                            else
                            {
                                if (finalStartOffset < 0.f)
                                    finalStartOffset = 0.f;
                            }
                            essence.startOffsetInSamples = finalStartOffset;
                        }
                        float grainAmp = voice.velocity;
                        scheduleGrainFn(
                            voice.firstGrainScheduled,
                            voice.punchyGrainPool,
                            voice.normalGrainPool,
                            grainDuration,
                            baseDelta,
                            sample,
                            grainAmp,
                            essence,
                            sampleLen,
                            raisedCosAttackSamples,
                            raisedCosReleaseSamples,
                            normalEnvelopeFn,
                            punchyEnvelopeFn
                        );
                        voice.grainSchedulerCounter += (grainIntervalInSamples + essence.gapAdjustment);
                    }
                }

                globalOffset += nextEvent;
            }
        }

        template <typename FrameDataType>
        void processFrame(FrameDataType& /*data*/)
        {
            // Not used
        }

        template <int P>
        void setParameter(double v)
        {
            if constexpr (P == 0)
            {
                grainPitchOffsetSemitones = v;
                updateDerivedParameters();
            }
            else if constexpr (P == 1)
            {
                grainOffsetCentsRange = v;
            }
            else if constexpr (P == 2)
            {
                grainVolumeMin = 1.0f - (float)v;
            }
            else if constexpr (P == 3)
            {
                grainPanRange = (float)v;
            }
            else if constexpr (P == 4)
            {
                grainGapAdjustmentMaxSec = v;
            }
            else if constexpr (P == 5)
            {
                grainSizeMS = v;
                updateDerivedParameters();
            }
            else if constexpr (P == 6)
            {
                grainIntervalMS = v;
                updateDerivedParameters();
            }
            else if constexpr (P == 7)
            {
                grainSizeRandom = (float)v;
            }
            else if constexpr (P == 8)
            {
                grainStartPercent = (float)v;
                updateDerivedParameters();
            }
            else if constexpr (P == 9)
            {
                startModTimeSec = v;
            }
            else if constexpr (P == 10)
            {
                startModEnabled = (v >= 0.5);
            }
            else if constexpr (P == 11)
            {
                grainSpray = (float)v;
            }
            else if constexpr (P == 12)
            {
                grainSprayMode = (v >= 0.5f) ? 1.0f : 0.0f;
            }
            else if constexpr (P == 13)
            {
                bool oldPunchyMode = punchyMode;
                punchyMode = (v >= 0.5);
                if (oldPunchyMode != punchyMode)
                {
                    if (punchyMode)
                        scheduleGrainFn = &Granular_Synth_2_Helper::scheduleGrainPunchy;
                    else
                        scheduleGrainFn = &Granular_Synth_2_Helper::scheduleGrainNormal;
                }
            }
            else if constexpr (P == 14)
            {
                envelopeType = (int)std::round(v * 2.0f);
                updateEnvelopeFunctions();
            }
        }

        void createParameters(ParameterDataList& data)
        {
            {
                parameter::data pitchOffsetParam("Pitch (semitones)", { -24.0, 24.0, 0.01 });
                registerCallback<0>(pitchOffsetParam);
                pitchOffsetParam.setDefaultValue(0.0);
                data.add(std::move(pitchOffsetParam));
            }
            {
                parameter::data offsetParam("Rand Pitch Detune", { 0.0, 100.0, 0.1 });
                registerCallback<1>(offsetParam);
                offsetParam.setDefaultValue(0.0);
                data.add(std::move(offsetParam));
            }
            {
                parameter::data volMinParam("Rand Vol", { 0.0, 0.8, 0.01 });
                registerCallback<2>(volMinParam);
                volMinParam.setDefaultValue(0.0);
                data.add(std::move(volMinParam));
            }
            {
                parameter::data panParam("Rand Pan", { 0.0, 1.0, 0.01 });
                registerCallback<3>(panParam);
                panParam.setDefaultValue(0.0);
                data.add(std::move(panParam));
            }
            {
                parameter::data gapParam("Rand Interval (sec)", { 0.0, 1.0, 0.01 });
                registerCallback<4>(gapParam);
                gapParam.setDefaultValue(0.0);
                data.add(std::move(gapParam));
            }
            {
                parameter::data sizeParam("Grain Size (ms)", { 10.0, 2000.0, 1.0 });
                registerCallback<5>(sizeParam);
                sizeParam.setDefaultValue(1000.0);
                data.add(std::move(sizeParam));
            }
            {
                parameter::data intervalParam("Grain Interval (ms)", { 10.0, 3000.0, 1.0 });
                registerCallback<6>(intervalParam);
                intervalParam.setDefaultValue(1500.0);
                data.add(std::move(intervalParam));
            }
            {
                parameter::data sizeRandomParam("Rand Size", { 0.0, 0.8, 0.01 });
                registerCallback<7>(sizeRandomParam);
                sizeRandomParam.setDefaultValue(0.0);
                data.add(std::move(sizeRandomParam));
            }
            {
                parameter::data startParam("Playhead Position", { 0.0, 1.0, 0.001 });
                registerCallback<8>(startParam);
                startParam.setDefaultValue(0.0);
                data.add(std::move(startParam));
            }
            {
                parameter::data startModTime("Scan Time (sec)", { 0.0, 20.0, 0.001 });
                registerCallback<9>(startModTime);
                startModTime.setDefaultValue(0.0);
                data.add(std::move(startModTime));
            }
            {
                parameter::data startModEnable("Scan Enable", { 0.0, 1.0, 1.0 });
                registerCallback<10>(startModEnable);
                startModEnable.setDefaultValue(0.0);
                data.add(std::move(startModEnable));
            }
            {
                parameter::data sprayParam("Spray", { 0.0, 1.0, 0.01 });
                registerCallback<11>(sprayParam);
                sprayParam.setDefaultValue(0.0);
                data.add(std::move(sprayParam));
            }
            {
                parameter::data sprayModeParam("Spray Mode", { 0.0, 1.0, 1.0 });
                registerCallback<12>(sprayModeParam);
                sprayModeParam.setDefaultValue(0.0);
                data.add(std::move(sprayModeParam));
            }
            {
                parameter::data punchyParam("Punchy Mode", { 0.0, 1.0, 1.0 });
                registerCallback<13>(punchyParam);
                punchyParam.setDefaultValue(0.0);
                data.add(std::move(punchyParam));
            }
            {
                parameter::data envTypeParam("Envelope Type", { 0.0, 1.0, 0.5f });
                registerCallback<14>(envTypeParam);
                envTypeParam.setDefaultValue(0.0);
                data.add(std::move(envTypeParam));
            }
        }

        void initPitchRatios()
        {
            for (int i = 0; i < 128; ++i)
                pitchRatios[i] = std::pow(2.0f, (float)(i - 60) / 12.0f);
        }
    };

} // namespace project
