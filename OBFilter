#pragma once
#include <JuceHeader.h>

// "Trapezoidal-Integrated 2-SVF Cascade + Global Feedback" filter
// referencing the 2020 DAFx paper (Werner & McClellan), but implemented
// with TPT integrators for each 2nd-order SVF, plus a global feedback
// path. This yields the characteristic "arched" 12 dB slope of Oberheim/
// CAT style designs for rDamping ~1.06.
//
// We rely on a one-sample feedback approach for the global path. For a
// truly exact approach, you'd solve a 4x4 system at every sample, which
// is far heavier. This TPT method is still advanced, stable, and commonly
// used in real-time plugins.
//
// Key features:
//  • Two trapezoidally integrated 2-pole SVFs in series => total 4th-order
//  • Global feedback from the second block's lowpass output back to the first
//  • "rDamping" sets the 2nd-order damping in each block
//  • "resonance" in [0..1] is the global feedback gain
//  • Keytracking is included
//  • Partial updates on parameter changes to keep runtime overhead low

namespace project
{
    using namespace juce;
    using namespace hise;
    using namespace scriptnode;

    template <int NV> // NV = number of voices
    struct Griffin_OBFilter : public data::base
    {
        SNEX_NODE(Griffin_OBFilter);

        struct MetadataClass
        {
            SN_NODE_ID("Griffin_OBFilter");
        };

        static constexpr bool isModNode() { return false; }
        static constexpr bool isPolyphonic() { return NV > 1; }
        static constexpr bool hasTail() { return false; }
        static constexpr bool isSuspendedOnSilence() { return false; }
        static constexpr int  getFixChannelAmount() { return 2; }

        static constexpr int  NumTables = 0;
        static constexpr int  NumSliderPacks = 0;
        static constexpr int  NumAudioFiles = 0;
        static constexpr int  NumFilters = 0;
        static constexpr int  NumDisplayBuffers = 0;

        //=================================================
        // prepare / reset
        //=================================================
        void prepare(PrepareSpecs specs)
        {
            sampleRate = specs.sampleRate;

            filtersLeft.prepare(specs);
            filtersRight.prepare(specs);

            for (auto& filter : filtersLeft)
                filter.prepare(sampleRate);

            for (auto& filter : filtersRight)
                filter.prepare(sampleRate);
        }

        void reset()
        {
            for (auto& filter : filtersLeft)
                filter.reset();

            for (auto& filter : filtersRight)
                filter.reset();
        }

        //=================================================
        // Main audio processing
        //=================================================
        template <typename ProcessDataType>
        void process(ProcessDataType& data)
        {
            auto& fixData = data.template as<ProcessData<getFixChannelAmount()>>();
            auto audioBlock = fixData.toAudioBlock();

            float* leftChannelData = audioBlock.getChannelPointer(0);
            float* rightChannelData = audioBlock.getChannelPointer(1);
            int numSamples = (int)data.getNumSamples();

            for (auto& leftFilter : filtersLeft)
                leftFilter.processBlock(leftChannelData, numSamples);

            for (auto& rightFilter : filtersRight)
                rightFilter.processBlock(rightChannelData, numSamples);
        }

        template <typename FrameDataType>
        void processFrame(FrameDataType& data) {}

        //=================================================
        // Per-voice audio effect:
        // 2 TPT-SVFs cascaded + global feedback
        //=================================================
        class AudioEffect
        {
        public:
            AudioEffect() = default;

            void prepare(float fs)
            {
                sampleRate = fs;
                baseCutoff = 1000.0f;
                resonance = 0.0f;
                rDamping = 1.06f; // typical "OB" arch
                keytrackAmount = 1.0f;
                storedNote = 60;

                reset();
                dirtyFlags = 0;
                updateAll();
            }

            void reset()
            {
                // 2 integrators per SVF => 4 total
                ic1aA = ic1bA = 0.0f;
                ic1aB = ic1bB = 0.0f;

                // For one-sample-late global feedback
                zInB = 0.0f;
            }

            //=================================================
            // param changes
            //=================================================
            enum DirtyFlags : uint32_t
            {
                changedCutoff = 1 << 0,
                changedResonance = 1 << 1,
                changedDamping = 1 << 2,
                changedKeytrack = 1 << 3,
                changedNote = 1 << 4
            };

            inline void setCutoff(float c)
            {
                baseCutoff = c;
                dirtyFlags |= changedCutoff;
            }

            inline void setResonance(float r)
            {
                resonance = r;
                dirtyFlags |= changedResonance;
            }

            inline void setDamping(float d)
            {
                rDamping = d;
                dirtyFlags |= changedDamping;
            }

            inline void setKeytrack(float kt)
            {
                keytrackAmount = kt;
                dirtyFlags |= changedKeytrack;
            }

            inline void setNoteNumber(int n)
            {
                storedNote = n;
                dirtyFlags |= changedNote;
            }

            inline void applyChangesIfNeeded()
            {
                if (dirtyFlags != 0)
                    updateAll();
            }

            //=================================================
            // The 2-SVF + feedback process
            //=================================================
            inline void processBlock(float* buffer, int numSamples)
            {
                applyChangesIfNeeded();

                for (int i = 0; i < numSamples; ++i)
                    buffer[i] = processSample(buffer[i]);
            }

        private:
            // TPT-based Chamberlin SVF, each block has:
            //   (ic1a, ic1b) as integrator states
            // We'll do 2 blocks in series, each with the same gVal and K,
            // then global feedback from block B output to block A input
            //
            // processSample does a 1-sample-late feedback approach

            inline float processSample(float x)
            {
                // 1) read previous sample's outB from zInB
                float lastOutB = zInB;

                // 2) feedBack = kGlobal * lastOutB
                //    input to block A is x - feedBack
                float fb = kGlobal * lastOutB;
                float inA = x - fb;

                //=== BLOCK A (2-pole TPT SVF) ===
                float vA = inA - (K * ic1bA) - ic1aA;
                float bandA = ic1bA + (gVal * vA);
                ic1bA = bandA;
                float lowA = ic1aA + (gVal * bandA);
                ic1aA = lowA;

                float outA = lowA; // 2-pole Lowpass

                //=== BLOCK B ===
                float vB = outA - (K * ic1bB) - ic1aB;
                float bandB = ic1bB + (gVal * vB);
                ic1bB = bandB;
                float lowB = ic1aB + (gVal * bandB);
                ic1aB = lowB;

                float outB = lowB;
                zInB = outB;  // store for next iteration feedback

                return outB;
            }

            inline void updateAll()
            {
                // compute final cutoff with keytrack
                float semitones = (float)storedNote - 60.0f;
                semitones *= keytrackAmount;
                float noteFactor = std::exp2f(0.0833333f * semitones);
                float fc = baseCutoff * noteFactor;

                // clamp
                if (fc < 20.0f)
                    fc = 20.0f;
                float nyqLimit = 0.49f * sampleRate;
                if (fc > nyqLimit)
                    fc = nyqLimit;

                // TPT: gVal = 2 * tan(pi * fc / fs)
                float normalized = fc / sampleRate;
                float warped = std::tan(MathConstants<float>::pi * normalized);
                gVal = 2.0f * warped;

                // clamp global feedback [0..1]
                if (resonance < 0.0f)
                    resonance = 0.0f;
                else if (resonance > 1.0f)
                    resonance = 1.0f;
                kGlobal = resonance;

                // K = 2*rDamping for each 2-pole block
                if (rDamping < 0.0f)
                    rDamping = 0.0f; // or clamp further if you prefer
                K = 2.0f * rDamping;

                dirtyFlags = 0;
            }

            //=================================================
            // internal
            //=================================================
            float sampleRate = 44100.0f;

            // parameters
            float baseCutoff = 1000.0f;
            float resonance = 0.0f;   // => global feedback
            float rDamping = 1.06f;  // internal 2pole damping
            float keytrackAmount = 1.0f;
            int   storedNote = 60;

            // derived TPT coefficients
            float gVal = 0.0f;
            float K = 2.0f;   // 2*rDamping
            float kGlobal = 0.0f;   // resonance feedback

            // integrator states for each 2-SVF
            float ic1aA = 0.0f, ic1bA = 0.0f;
            float ic1aB = 0.0f, ic1bB = 0.0f;

            // store last outB for 1-sample-late feedback
            float zInB = 0.0f;

            uint32_t dirtyFlags = 0;
        };

        //=================================================
        // Parameter callback
        //=================================================
        template <int P>
        void setParameter(double val)
        {
            if (P == 0) // cutoff
            {
                cutoffFrequency = (float)val;
                for (auto& fl : filtersLeft)
                {
                    fl.setCutoff(cutoffFrequency);
                    fl.applyChangesIfNeeded();
                }
                for (auto& fr : filtersRight)
                {
                    fr.setCutoff(cutoffFrequency);
                    fr.applyChangesIfNeeded();
                }
            }
            else if (P == 1) // resonance => global feedback
            {
                resonance = (float)val;
                for (auto& fl : filtersLeft)
                {
                    fl.setResonance(resonance);
                    fl.applyChangesIfNeeded();
                }
                for (auto& fr : filtersRight)
                {
                    fr.setResonance(resonance);
                    fr.applyChangesIfNeeded();
                }
            }
            else if (P == 2) // keytrack
            {
                keytrackAmount = (float)val;
                for (auto& fl : filtersLeft)
                {
                    fl.setKeytrack(keytrackAmount);
                    fl.applyChangesIfNeeded();
                }
                for (auto& fr : filtersRight)
                {
                    fr.setKeytrack(keytrackAmount);
                    fr.applyChangesIfNeeded();
                }
            }
            else if (P == 3) // damping
            {
                rDamp = (float)val;
                for (auto& fl : filtersLeft)
                {
                    fl.setDamping(rDamp);
                    fl.applyChangesIfNeeded();
                }
                for (auto& fr : filtersRight)
                {
                    fr.setDamping(rDamp);
                    fr.applyChangesIfNeeded();
                }
            }
        }

        //=================================================
        // define parameters
        //=================================================
        void createParameters(ParameterDataList& data)
        {
            {
                parameter::data p("Cutoff Frequency", { 20.0, 20000.0, 1.0 });
                registerCallback<0>(p);
                p.setDefaultValue(1000.0f);
                data.add(std::move(p));
            }
            {
                parameter::data p("Resonance", { 0.0, 1.0, 0.01 });
                registerCallback<1>(p);
                p.setDefaultValue(0.0f);
                data.add(std::move(p));
            }
            {
                parameter::data p("Keytrack Amount", { -1.0, 1.0, 0.01 });
                registerCallback<2>(p);
                p.setDefaultValue(1.0f);
                data.add(std::move(p));
            }
            {
                parameter::data p("SVF Damping (r)", { 0.0, 2.0, 0.01 });
                registerCallback<3>(p);
                p.setDefaultValue(1.06f);
                data.add(std::move(p));
            }
        }

        void setExternalData(const ExternalData& data, int index) {}

        //=================================================
        // handle note on
        //=================================================
        void handleHiseEvent(HiseEvent& e)
        {
            if (e.isNoteOn())
            {
                filtersLeft.get().setNoteNumber(e.getNoteNumber());
                filtersLeft.get().applyChangesIfNeeded();

                filtersRight.get().setNoteNumber(e.getNoteNumber());
                filtersRight.get().applyChangesIfNeeded();
            }
        }

    private:
        PolyData<AudioEffect, NV> filtersLeft;
        PolyData<AudioEffect, NV> filtersRight;

        float cutoffFrequency = 1000.0f;
        float resonance = 0.0f;
        float keytrackAmount = 1.0f;
        float rDamp = 1.06f;  // default damping

        float sampleRate = 44100.0f;
    };
}
