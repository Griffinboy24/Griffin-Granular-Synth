#pragma once
#include <JuceHeader.h>

/*
   ================================================================================
   OB8-Tuned 2-SVF + Global Feedback Filter with Sample-by-Sample Parameter
   Updates & Optimized Closed-Form Matrix Inversion

   This implementation uses the exact delay-free state-space method from
   "Moog Ladder Filter Generalizations Based on State Variable Filters"
   (Werner & McClellan, DAFx-2020), tuned for the OB8:
      - Fixed local damping r = 3.4f (OB8 tuning)
      - "Resonance" (feedback) range is [0, 35.0]
      - Global feedback sign is negative (i.e. Acont[0][3] = -kf)

   To preserve accurate modulation and key tracking, parameters are updated
   every sample. To mitigate the CPU load from matrix inversion, we use a
   closed-form solution that exploits the structure of M = I - g*A.

   ================================================================================
*/

namespace project
{
    using namespace juce;
    using namespace hise;
    using namespace scriptnode;

    template <int NV> // NV = number of voices
    struct Griffin_OBFilter : public data::base
    {
        SNEX_NODE(Griffin_OBFilter);

        struct MetadataClass { SN_NODE_ID("Griffin_OBFilter"); };

        static constexpr bool isModNode() { return false; }
        static constexpr bool isPolyphonic() { return NV > 1; }
        static constexpr bool hasTail() { return false; }
        static constexpr bool isSuspendedOnSilence() { return false; }
        static constexpr int  getFixChannelAmount() { return 2; }

        static constexpr int  NumTables = 0;
        static constexpr int  NumSliderPacks = 0;
        static constexpr int  NumAudioFiles = 0;
        static constexpr int  NumFilters = 0;
        static constexpr int  NumDisplayBuffers = 0;

        // Parameters (raw values)
        float cutoffFrequency = 1000.0f;
        float resonance = 0.0f;    // range: [0, 35]
        float keytrackAmount = 1.0f;

        float sampleRate = 44100.0f;

        // Smoothing objects for per-sample smoothing
       SmoothedValue<float> cutoffSmooth;
        SmoothedValue<float> resonanceSmooth;
        SmoothedValue<float> keytrackSmooth;

        //-------------------------------------------------------------------------
        // prepare() sets up the voices and initializes the smoothers
        //-------------------------------------------------------------------------
        void prepare(PrepareSpecs specs)
        {
            sampleRate = specs.sampleRate;
            filtersLeft.prepare(specs);
            filtersRight.prepare(specs);

            for (auto& v : filtersLeft)
                v.prepare(sampleRate);
            for (auto& v : filtersRight)
                v.prepare(sampleRate);

            // Set smoothing time to 10ms (these affect only parameter changes)
            cutoffSmooth.reset(sampleRate, 0.01);
            resonanceSmooth.reset(sampleRate, 0.01);
            keytrackSmooth.reset(sampleRate, 0.01);

            cutoffSmooth.setCurrentAndTargetValue(cutoffFrequency);
            resonanceSmooth.setCurrentAndTargetValue(resonance);
            keytrackSmooth.setCurrentAndTargetValue(keytrackAmount);
        }

        void reset()
        {
            for (auto& v : filtersLeft)
                v.reset();
            for (auto& v : filtersRight)
                v.reset();
        }

        //-------------------------------------------------------------------------
        // Process audio: update parameters every sample using smoothed values
        //-------------------------------------------------------------------------
        template <typename ProcessDataType>
        void process(ProcessDataType& data)
        {
            auto& fixData = data.template as<ProcessData<getFixChannelAmount()>>();
            auto audioBlock = fixData.toAudioBlock();

            float* leftCh = audioBlock.getChannelPointer(0);
            float* rightCh = audioBlock.getChannelPointer(1);
            int numSamples = (int)data.getNumSamples();

            for (int i = 0; i < numSamples; ++i)
            {
                // Get per-sample smoothed parameter values
                float cVal = cutoffSmooth.getNextValue();
                float rVal = resonanceSmooth.getNextValue();
                float kVal = keytrackSmooth.getNextValue();

                // Update every voice (modulation/keytracking must update every sample)
                for (auto& v : filtersLeft)
                {
                    v.setCutoff(cVal);
                    v.setResonance(rVal);
                    v.setKeytrack(kVal);
                    v.applyChangesIfNeeded(); // This now uses the optimized inversion
                }
                for (auto& v : filtersRight)
                {
                    v.setCutoff(cVal);
                    v.setResonance(rVal);
                    v.setKeytrack(kVal);
                    v.applyChangesIfNeeded();
                }

                // Process the sample for each voice in series (or sum as needed)
                float outL = leftCh[i];
                float outR = rightCh[i];
                for (auto& v : filtersLeft)
                    outL = v.processSample(outL);
                for (auto& v : filtersRight)
                    outR = v.processSample(outR);

                leftCh[i] = outL;
                rightCh[i] = outR;
            }
        }

        template <typename FrameDataType>
        void processFrame(FrameDataType& data) {}

        //-------------------------------------------------------------------------
        // OB8-Style Voice-Level Filter
        //-------------------------------------------------------------------------
        class AudioEffect
        {
        public:
            AudioEffect() = default;

            void prepare(float fs)
            {
                sampleRate = fs;
                baseCutoff = 1000.0f;
                resonance = 0.0f;    // User resonance range [0, 35]
                rDamping = 3.4f;    // Fixed for OB8 tuning
                keytrackAmount = 1.0f;
                storedNote = 60;
                reset();
                dirtyFlags = 0;
                updateAll(); // Initialize state-space matrices
            }

            void reset()
            {
                for (int i = 0; i < 4; ++i)
                    x[i] = 0.0f;
            }

            enum Dirty : uint32_t
            {
                changedCutoff = 1 << 0,
                changedResonance = 1 << 1,
                changedKeytrack = 1 << 2,
                changedNote = 1 << 3
            };

            inline void setCutoff(float c)
            {
                baseCutoff = c;
                dirtyFlags |= changedCutoff;
            }
            inline void setResonance(float r)
            {
                resonance = r;
                dirtyFlags |= changedResonance;
            }
            inline void setKeytrack(float kt)
            {
                keytrackAmount = kt;
                dirtyFlags |= changedKeytrack;
            }
            inline void setNoteNumber(int n)
            {
                storedNote = n;
                dirtyFlags |= changedNote;
            }
            inline void applyChangesIfNeeded()
            {
                // For per-sample updates, this is called every sample.
                updateAll();
            }

            inline float processSample(float in)
            {
                // Optionally add a tiny noise floor to break symmetry
                constexpr float noiseFloor = 0.0001f;
                in += noiseFloor * (noiseGen.nextFloat() - 0.5f);

                // Update state-space every sample using the optimized closed-form inversion
                // (Parameters are assumed already updated via setCutoff, etc.)
                // We assume updateAll() was already called in applyChangesIfNeeded().

                float temp[4];
                mulMatVec4(N, x, temp);
                temp[0] += gB[0] * in;
                temp[1] += gB[1] * in;
                temp[2] += gB[2] * in;
                temp[3] += gB[3] * in;

                float newX[4];
                // Use our optimized MInv (computed in updateAll)
                mulMatVec4(MInv, temp, newX);

                float out = C[0] * newX[0] + C[1] * newX[1] +
                    C[2] * newX[2] + C[3] * newX[3];

                for (int i = 0; i < 4; ++i)
                    x[i] = newX[i];

                return out;
            }

        private:
            // Optimized updateAll() computes MInv using closed-form formulas
            void updateAll()
            {
                // Compute effective cutoff with keytracking
                float semitones = ((float)storedNote - 60.0f) * keytrackAmount;
                float noteFactor = std::exp2f(0.0833333f * semitones);
                float fc = baseCutoff * noteFactor;
                if (fc < 20.0f) fc = 20.0f;
                float limit = 0.49f * sampleRate;
                if (fc > limit) fc = limit;

                // Compute TPT warp factor
                float norm = fc / sampleRate;
                float warped = std::tan(MathConstants<float>::pi * norm);
                g = 2.0f * warped;

                // Build continuous-time state-space (OB8 tuning)
                // For OB8:
                //   rDamping is fixed at 3.4f
                //   Acont[0] = [ -2*r, -1, 0, -kf ]
                //   where kf = resonance.
                buildContinuousTimeSystem();

                // Build discrete-time matrices using TPT: M = I - gA, N = I + gA, and compute gB = g*B.
                buildDiscreteTimeMatrices();

                // Instead of a generic inversion, use our optimized closed-form inversion:
                computeOptimizedMInv();

                // Copy Ccont to C (for output)
                for (int i = 0; i < 4; ++i)
                    C[i] = Ccont[i];

                dirtyFlags = 0;
            }

            // Optimized inversion for M = I - gA given its structure:
            // M = [ [a, b, 0, c],
            //       [-b, 1, 0, 0],
            //       [0, -b, a, b],
            //       [0,  0, -b, 1] ]
            // where:
            //   a = 1 + 2*g*rDamping,
            //   b = g,
            //   c = g * resonance.
            inline void computeOptimizedMInv()
            {
                const float a = 1.0f + 2.0f * g * rDamping;
                const float b = g;
                const float c = g * resonance;
                const float D = a + b * b;  // determinant factor for the 2x2 block

                // Inverse of A11 = [ [a, b], [-b, 1] ]
                const float inv00 = 1.0f / D;
                const float inv01 = -b / D;
                const float inv10 = b / D;
                const float inv11 = a / D;

                // Upper-right block: -A11_inv * A12 * A11_inv,
                // where A12 = [ [0, c], [0, 0] ]
                const float ur00 = -(c * inv00 * inv10); // = -c*(inv00*inv10)
                const float ur01 = -(c * inv00 * inv11); // = -c*(inv00*inv11)
                const float ur10 = -(c * inv10 * inv10); // = -c*(inv10*inv10)
                const float ur11 = -(c * inv10 * inv11); // = -c*(inv10*inv11)

                // Construct MInv in block form:
                // Upper-left 2x2 block = A11_inv:
                MInv[0][0] = inv00; MInv[0][1] = inv01;
                MInv[1][0] = inv10; MInv[1][1] = inv11;
                // Upper-right 2x2 block = computed above:
                MInv[0][2] = ur00; MInv[0][3] = ur01;
                MInv[1][2] = ur10; MInv[1][3] = ur11;
                // Lower-left block is zero:
                MInv[2][0] = 0.0f; MInv[2][1] = 0.0f;
                MInv[3][0] = 0.0f; MInv[3][1] = 0.0f;
                // Lower-right 2x2 block = A11_inv (same as upper-left):
                MInv[2][2] = inv00; MInv[2][3] = inv01;
                MInv[3][2] = inv10; MInv[3][3] = inv11;
            }

            void buildContinuousTimeSystem()
            {
                // For OB8 tuning:
                // rDamping is fixed at 3.4; resonance is as set by the user.
                const float r = rDamping;
                const float kf = resonance;
                for (int rr = 0; rr < 4; ++rr)
                    for (int cc = 0; cc < 4; ++cc)
                        Acont[rr][cc] = 0.0f;
                for (int i = 0; i < 4; ++i)
                {
                    Bcont[i] = 0.0f;
                    Ccont[i] = 0.0f;
                }
                Acont[0][0] = -2.0f * r;
                Acont[0][1] = -1.0f;
                Acont[0][3] = -kf;
                Acont[1][0] = 1.0f;
                Acont[2][1] = 1.0f;
                Acont[2][2] = -2.0f * r;
                Acont[2][3] = -1.0f;
                Acont[3][2] = 1.0f;

                Bcont[0] = 1.0f;  // input goes to x1'
                Ccont[3] = 1.0f;  // output from x4
            }

            void buildDiscreteTimeMatrices()
            {
                float gA[4][4];
                for (int rr = 0; rr < 4; ++rr)
                {
                    for (int cc = 0; cc < 4; ++cc)
                        gA[rr][cc] = g * Acont[rr][cc];
                }
                for (int rr = 0; rr < 4; ++rr)
                {
                    for (int cc = 0; cc < 4; ++cc)
                    {
                        float valMinus = ((rr == cc) ? 1.0f : 0.0f) - gA[rr][cc];
                        float valPlus = ((rr == cc) ? 1.0f : 0.0f) + gA[rr][cc];
                        M[rr][cc] = valMinus;
                        N[rr][cc] = valPlus;
                    }
                }
                for (int i = 0; i < 4; ++i)
                    gB[i] = g * Bcont[i];
            }

            static void invert4x4(const float src[4][4], float dst[4][4])
            {
                // Fallback generic inversion (should not be used with our optimized MInv)
                float tmp[4][8];
                for (int r = 0; r < 4; ++r)
                {
                    for (int c = 0; c < 4; ++c)
                        tmp[r][c] = src[r][c];
                    for (int c = 4; c < 8; ++c)
                        tmp[r][c] = ((c - 4) == r) ? 1.0f : 0.0f;
                }
                for (int c = 0; c < 4; ++c)
                {
                    float pivot = tmp[c][c];
                    if (std::fabs(pivot) < 1.0e-12f)
                        pivot = 1.0e-12f;
                    for (int cc = 0; cc < 8; ++cc)
                        tmp[c][cc] /= pivot;
                    for (int r = 0; r < 4; ++r)
                    {
                        if (r != c)
                        {
                            float factor = tmp[r][c];
                            for (int cc = c; cc < 8; ++cc)
                                tmp[r][cc] -= factor * tmp[c][cc];
                        }
                    }
                }
                for (int r = 0; r < 4; ++r)
                    for (int c = 0; c < 4; ++c)
                        dst[r][c] = tmp[r][c + 4];
            }

            static void mulMatVec4(const float mat[4][4], const float vec[4], float out[4])
            {
                for (int rr = 0; rr < 4; ++rr)
                {
                    float sum = 0.0f;
                    for (int cc = 0; cc < 4; ++cc)
                        sum += mat[rr][cc] * vec[cc];
                    out[rr] = sum;
                }
            }

            float sampleRate = 44100.0f;
            float baseCutoff = 1000.0f;
            float resonance = 0.0f;
            float rDamping = 3.4f; // fixed for OB8 tuning
            float keytrackAmount = 1.0f;
            int storedNote = 60;

            float x[4] = { 0.f, 0.f, 0.f, 0.f };
            float g = 0.0f;

            float Acont[4][4];
            float Bcont[4];
            float Ccont[4];
            float M[4][4], N[4][4], MInv[4][4];
            float gB[4];
            float C[4];

            uint32_t dirtyFlags = 0;
            juce::Random noiseGen;
        };

        //-------------------------------------------------------------------------
        // Parameter setting (per sample update)
        //-------------------------------------------------------------------------
        template <int P>
        void setParameter(double val)
        {
            if (P == 0)
            {
                cutoffFrequency = (float)val;
                cutoffSmooth.setTargetValue(cutoffFrequency);
            }
            else if (P == 1)
            {
                resonance = (float)val;
                if (resonance < 0.0f)
                    resonance = 0.0f;
                if (resonance > 35.0f)
                    resonance = 35.0f;
                resonanceSmooth.setTargetValue(resonance);
            }
            else if (P == 2)
            {
                keytrackAmount = (float)val;
                keytrackSmooth.setTargetValue(keytrackAmount);
            }
        }

        void createParameters(ParameterDataList& data)
        {
            {
                parameter::data p("Cutoff Frequency", { 20.0, 20000.0, 1.0 });
                registerCallback<0>(p);
                p.setDefaultValue(1000.0f);
                data.add(std::move(p));
            }
            {
                parameter::data p("Resonance", { 0.0, 35.0, 0.01 });
                registerCallback<1>(p);
                p.setDefaultValue(0.0f);
                data.add(std::move(p));
            }
            {
                parameter::data p("Keytrack Amount", { -1.0, 1.0, 0.01 });
                registerCallback<2>(p);
                p.setDefaultValue(1.0f);
                data.add(std::move(p));
            }
        }

        void setExternalData(const ExternalData& data, int index) {}

        //-------------------------------------------------------------------------
        // Note handling
        //-------------------------------------------------------------------------
        void handleHiseEvent(HiseEvent& e)
        {
            if (e.isNoteOn())
            {
                filtersLeft.get().setNoteNumber(e.getNoteNumber());
                filtersLeft.get().applyChangesIfNeeded();

                filtersRight.get().setNoteNumber(e.getNoteNumber());
                filtersRight.get().applyChangesIfNeeded();
            }
        }

    private:
        PolyData<AudioEffect, NV> filtersLeft;
        PolyData<AudioEffect, NV> filtersRight;
    };
}
